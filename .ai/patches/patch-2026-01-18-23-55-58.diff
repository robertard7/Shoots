diff --git a/src/Builder/Shoots.Builder.Cli/Program.cs b/src/Builder/Shoots.Builder.Cli/Program.cs
index cf2b4ac..a6c16bc 100644
--- a/src/Builder/Shoots.Builder.Cli/Program.cs
+++ b/src/Builder/Shoots.Builder.Cli/Program.cs
@@ -143,7 +143,7 @@ for (var i = 0; i < args.Length; i++)
             return 1;
         }
 
-        routeRules.Add(new RouteRule(parts[0], intent, owner, parts[3]));
+        routeRules.Add(new RouteRule(parts[0], intent, owner, parts[3], MermaidNodeKind.Linear, Array.Empty<string>()));
         continue;
     }
 
diff --git a/src/Builder/Shoots.Builder.Core/DeterministicBuildPlanner.cs b/src/Builder/Shoots.Builder.Core/DeterministicBuildPlanner.cs
index 4968dd6..37f8fc1 100644
--- a/src/Builder/Shoots.Builder.Core/DeterministicBuildPlanner.cs
+++ b/src/Builder/Shoots.Builder.Core/DeterministicBuildPlanner.cs
@@ -74,13 +74,6 @@ public sealed class DeterministicBuildPlanner : IBuildPlanner
             .ThenBy(rule => rule.AllowedOutputKind, StringComparer.Ordinal)
             .ToList();
 
-        var normalizedRequest = request with
-        {
-            CommandId = normalizedCommandId,
-            Args = normalizedArgs,
-            RouteRules = normalizedRouteRules
-        };
-
         // Deterministic steps
         var stepsById = new Dictionary<string, BuildStep>(StringComparer.Ordinal);
         var routeRulesByNode = normalizedRouteRules.ToDictionary(
@@ -93,11 +86,23 @@ public sealed class DeterministicBuildPlanner : IBuildPlanner
         if (spec is null)
             throw new InvalidOperationException($"unknown command '{normalizedCommandId}'");
 
+        var startNodes = MermaidPlanGraph.GetStartNodes(graph);
+        if (startNodes.Count != 1)
+            throw new InvalidOperationException($"graph must have exactly one start node (found {startNodes.Count}).");
+
+        var terminalNodes = MermaidPlanGraph.GetTerminalNodes(graph);
+
         foreach (var nodeId in orderedStepIds)
         {
             if (!routeRulesByNode.TryGetValue(nodeId, out var rule))
                 continue;
 
+            var allowedNextNodes = graph.Adjacency.TryGetValue(nodeId, out var adjacency)
+                ? adjacency
+                : Array.Empty<string>();
+
+            var nodeKind = ResolveNodeKind(nodeId, startNodes, allowedNextNodes);
+
             stepsById[nodeId] = new RouteStep(
                 Id: nodeId,
                 Description: $"Route '{nodeId}' intent={rule.Intent} owner={rule.Owner}.",
@@ -106,6 +111,12 @@ public sealed class DeterministicBuildPlanner : IBuildPlanner
                 Owner: rule.Owner,
                 WorkOrderId: request.WorkOrder.Id
             );
+
+            routeRulesByNode[nodeId] = rule with
+            {
+                NodeKind = nodeKind,
+                AllowedNextNodes = allowedNextNodes
+            };
         }
 
         var unknownRouteNodes = routeRulesByNode.Keys
@@ -126,16 +137,29 @@ public sealed class DeterministicBuildPlanner : IBuildPlanner
         if (missingIntents.Length > 0)
             throw new InvalidOperationException($"route rules missing required intents: {string.Join(", ", missingIntents)}");
 
-        var startNodes = MermaidPlanGraph.GetStartNodes(graph);
-        if (startNodes.Count != 1)
-            throw new InvalidOperationException($"graph must have exactly one start node (found {startNodes.Count}).");
-
-        var terminalNodes = MermaidPlanGraph.GetTerminalNodes(graph);
         var hasTerminalIntent = terminalNodes.Any(
             nodeId => routeRulesByNode.TryGetValue(nodeId, out var rule) && rule.Intent == RouteIntent.Terminate);
         if (!hasTerminalIntent)
             throw new InvalidOperationException("graph must include at least one terminal node with Terminate intent.");
 
+        foreach (var rule in routeRulesByNode.Values)
+        {
+            if (rule.Intent == RouteIntent.Terminate && rule.AllowedNextNodes.Count > 0)
+                throw new InvalidOperationException($"terminate node '{rule.NodeId}' must not have outbound edges.");
+        }
+
+        var normalizedRequest = request with
+        {
+            CommandId = normalizedCommandId,
+            Args = normalizedArgs,
+            RouteRules = routeRulesByNode.Values
+                .OrderBy(rule => rule.NodeId, StringComparer.Ordinal)
+                .ThenBy(rule => rule.Intent)
+                .ThenBy(rule => rule.Owner)
+                .ThenBy(rule => rule.AllowedOutputKind, StringComparer.Ordinal)
+                .ToList()
+        };
+
         var steps = orderedStepIds
             .Select(stepId => stepsById[stepId])
             .ToList();
@@ -186,4 +210,21 @@ public sealed class DeterministicBuildPlanner : IBuildPlanner
             Artifacts: artifacts
         );
     }
+
+    private static MermaidNodeKind ResolveNodeKind(
+        string nodeId,
+        IReadOnlyList<string> startNodes,
+        IReadOnlyList<string> allowedNextNodes)
+    {
+        if (startNodes.Contains(nodeId, StringComparer.Ordinal))
+            return MermaidNodeKind.Start;
+
+        if (allowedNextNodes.Count == 0)
+            return MermaidNodeKind.Terminate;
+
+        if (allowedNextNodes.Count > 1)
+            return MermaidNodeKind.Gate;
+
+        return MermaidNodeKind.Linear;
+    }
 }
diff --git a/src/Builder/Shoots.Builder.Core/MermaidPlanGraph.cs b/src/Builder/Shoots.Builder.Core/MermaidPlanGraph.cs
index a053071..c249769 100644
--- a/src/Builder/Shoots.Builder.Core/MermaidPlanGraph.cs
+++ b/src/Builder/Shoots.Builder.Core/MermaidPlanGraph.cs
@@ -63,7 +63,8 @@ internal static class MermaidPlanGraph
         if (nodes.Count == 0)
             throw new InvalidOperationException("graph must contain at least one node");
 
-        return new GraphDefinition(nodes.ToArray(), edges);
+        var adjacency = BuildAdjacency(nodes, edges);
+        return new GraphDefinition(nodes.ToArray(), edges, adjacency);
     }
 
     public static IReadOnlyList<string> OrderStepIds(string graphText)
@@ -169,7 +170,31 @@ internal static class MermaidPlanGraph
         return ordered;
     }
 
+    private static IReadOnlyDictionary<string, IReadOnlyList<string>> BuildAdjacency(
+        IEnumerable<string> nodes,
+        IEnumerable<(string From, string To)> edges)
+    {
+        var adjacency = nodes.ToDictionary(
+            node => node,
+            _ => new SortedSet<string>(StringComparer.Ordinal),
+            StringComparer.Ordinal);
+
+        foreach (var (from, to) in edges)
+        {
+            if (!adjacency.TryGetValue(from, out var targets))
+                continue;
+
+            targets.Add(to);
+        }
+
+        return adjacency.ToDictionary(
+            pair => pair.Key,
+            pair => (IReadOnlyList<string>)pair.Value.ToArray(),
+            StringComparer.Ordinal);
+    }
+
     internal sealed record GraphDefinition(
         IReadOnlyList<string> Nodes,
-        IReadOnlyList<(string From, string To)> Edges);
+        IReadOnlyList<(string From, string To)> Edges,
+        IReadOnlyDictionary<string, IReadOnlyList<string>> Adjacency);
 }
diff --git a/src/Builder/Shoots.Builder.Tests/BuilderContractTests.cs b/src/Builder/Shoots.Builder.Tests/BuilderContractTests.cs
index a508198..8d001ab 100644
--- a/src/Builder/Shoots.Builder.Tests/BuilderContractTests.cs
+++ b/src/Builder/Shoots.Builder.Tests/BuilderContractTests.cs
@@ -27,10 +27,10 @@ public sealed class BuilderContractTests
             },
             RouteRules: new[]
             {
-                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection"),
-                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation"),
-                new RouteRule("review", RouteIntent.Review, DecisionOwner.Human, "review"),
-                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection", MermaidNodeKind.Linear, Array.Empty<string>()),
+                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation", MermaidNodeKind.Linear, Array.Empty<string>()),
+                new RouteRule("review", RouteIntent.Review, DecisionOwner.Human, "review", MermaidNodeKind.Linear, Array.Empty<string>()),
+                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Linear, Array.Empty<string>())
             }
         );
 
diff --git a/src/Builder/Shoots.Builder.Tests/DeterministicPlannerTests.cs b/src/Builder/Shoots.Builder.Tests/DeterministicPlannerTests.cs
index b4ec361..41ea73b 100644
--- a/src/Builder/Shoots.Builder.Tests/DeterministicPlannerTests.cs
+++ b/src/Builder/Shoots.Builder.Tests/DeterministicPlannerTests.cs
@@ -27,10 +27,10 @@ public sealed class DeterministicPlannerTests
                 ["b"] = "2",
                 ["a"] = "1"
             },
-            new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection"),
-            new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation"),
-            new RouteRule("review", RouteIntent.Review, DecisionOwner.Human, "review"),
-            new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination"));
+            new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection", MermaidNodeKind.Linear, Array.Empty<string>()),
+            new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation", MermaidNodeKind.Linear, Array.Empty<string>()),
+            new RouteRule("review", RouteIntent.Review, DecisionOwner.Human, "review", MermaidNodeKind.Linear, Array.Empty<string>()),
+            new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Linear, Array.Empty<string>()));
 
         var firstPlan = planner.Plan(request);
         var secondPlan = planner.Plan(request);
@@ -52,10 +52,10 @@ public sealed class DeterministicPlannerTests
             "core.ping",
             "graph TD; select --> validate --> review --> terminate",
             null,
-            new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection"),
-            new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation"),
-            new RouteRule("review", RouteIntent.Review, DecisionOwner.Human, "review"),
-            new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination"));
+            new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection", MermaidNodeKind.Linear, Array.Empty<string>()),
+            new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation", MermaidNodeKind.Linear, Array.Empty<string>()),
+            new RouteRule("review", RouteIntent.Review, DecisionOwner.Human, "review", MermaidNodeKind.Linear, Array.Empty<string>()),
+            new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Linear, Array.Empty<string>()));
 
         var plan = planner.Plan(request);
         var computed = BuildPlanHasher.ComputePlanId(plan.Request, plan.Authority, plan.Steps, plan.Artifacts);
@@ -93,10 +93,10 @@ public sealed class DeterministicPlannerTests
             "core.ping",
             "graph TD; select --> review --> validate --> terminate",
             null,
-            new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection"),
-            new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation"),
-            new RouteRule("review", RouteIntent.Review, DecisionOwner.Human, "review"),
-            new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination"));
+            new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection", MermaidNodeKind.Linear, Array.Empty<string>()),
+            new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation", MermaidNodeKind.Linear, Array.Empty<string>()),
+            new RouteRule("review", RouteIntent.Review, DecisionOwner.Human, "review", MermaidNodeKind.Linear, Array.Empty<string>()),
+            new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Linear, Array.Empty<string>()));
 
         var plan = planner.Plan(request);
 
@@ -119,10 +119,10 @@ public sealed class DeterministicPlannerTests
             "core.ping",
             "graph TD; select --> validate",
             null,
-            new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection"),
-            new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation"),
-            new RouteRule("review", RouteIntent.Review, DecisionOwner.Human, "review"),
-            new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination"));
+            new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection", MermaidNodeKind.Linear, Array.Empty<string>()),
+            new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation", MermaidNodeKind.Linear, Array.Empty<string>()),
+            new RouteRule("review", RouteIntent.Review, DecisionOwner.Human, "review", MermaidNodeKind.Linear, Array.Empty<string>()),
+            new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Linear, Array.Empty<string>()));
 
         Assert.Throws<InvalidOperationException>(() => planner.Plan(request));
     }
diff --git a/src/Builder/Shoots.Builder.Tests/PlannerSerializationTests.cs b/src/Builder/Shoots.Builder.Tests/PlannerSerializationTests.cs
index af70940..f01afea 100644
--- a/src/Builder/Shoots.Builder.Tests/PlannerSerializationTests.cs
+++ b/src/Builder/Shoots.Builder.Tests/PlannerSerializationTests.cs
@@ -29,10 +29,10 @@ public sealed class PlannerSerializationTests
                 ["b"] = "2",
                 ["a"] = "1"
             },
-            new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection"),
-            new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation"),
-            new RouteRule("review", RouteIntent.Review, DecisionOwner.Human, "review"),
-            new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination"));
+            new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection", MermaidNodeKind.Linear, Array.Empty<string>()),
+            new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation", MermaidNodeKind.Linear, Array.Empty<string>()),
+            new RouteRule("review", RouteIntent.Review, DecisionOwner.Human, "review", MermaidNodeKind.Linear, Array.Empty<string>()),
+            new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Linear, Array.Empty<string>()));
 
         var plan = planner.Plan(request);
         var planText = BuildPlanRenderer.RenderText(plan);
diff --git a/src/Contracts/Shoots.Contracts.Core/RouteContracts.cs b/src/Contracts/Shoots.Contracts.Core/RouteContracts.cs
index c69c500..fd301a0 100644
--- a/src/Contracts/Shoots.Contracts.Core/RouteContracts.cs
+++ b/src/Contracts/Shoots.Contracts.Core/RouteContracts.cs
@@ -1,3 +1,5 @@
+using System.Collections.Generic;
+
 namespace Shoots.Contracts.Core;
 
 /// <summary>
@@ -22,6 +24,17 @@ public enum DecisionOwner
     Rule
 }
 
+/// <summary>
+/// Deterministic Mermaid node kind.
+/// </summary>
+public enum MermaidNodeKind
+{
+    Start,
+    Gate,
+    Linear,
+    Terminate
+}
+
 /// <summary>
 /// Deterministic routing rule.
 /// </summary>
@@ -29,5 +42,7 @@ public sealed record RouteRule(
     string NodeId,
     RouteIntent Intent,
     DecisionOwner Owner,
-    string AllowedOutputKind
+    string AllowedOutputKind,
+    MermaidNodeKind NodeKind,
+    IReadOnlyList<string> AllowedNextNodes
 );
diff --git a/src/Contracts/Shoots.Contracts.Core/RouteDecision.cs b/src/Contracts/Shoots.Contracts.Core/RouteDecision.cs
new file mode 100644
index 0000000..fdc394e
--- /dev/null
+++ b/src/Contracts/Shoots.Contracts.Core/RouteDecision.cs
@@ -0,0 +1,9 @@
+namespace Shoots.Contracts.Core;
+
+/// <summary>
+/// Deterministic routing decision payload.
+/// </summary>
+public sealed record RouteDecision(
+    string NextNodeId,
+    ToolSelectionDecision? ToolSelection = null
+);
diff --git a/src/Providers/Shoots.Providers.Abstractions/IAiProviderAdapter.cs b/src/Providers/Shoots.Providers.Abstractions/IAiProviderAdapter.cs
index 2d5340c..72d0c02 100644
--- a/src/Providers/Shoots.Providers.Abstractions/IAiProviderAdapter.cs
+++ b/src/Providers/Shoots.Providers.Abstractions/IAiProviderAdapter.cs
@@ -1,12 +1,15 @@
+using System.Collections.Generic;
 using Shoots.Contracts.Core;
 
 namespace Shoots.Providers.Abstractions;
 
 public interface IAiProviderAdapter
 {
-    ToolSelectionDecision? RequestDecision(
+    RouteDecision? RequestDecision(
         WorkOrder workOrder,
         RouteStep step,
+        MermaidNodeKind nodeKind,
+        IReadOnlyList<string> allowedNextNodes,
         string catalogHash,
         string routingTraceSummary);
 }
diff --git a/src/Providers/Shoots.Providers.Bridge/BridgeAiDecisionProvider.cs b/src/Providers/Shoots.Providers.Bridge/BridgeAiDecisionProvider.cs
index 3e50e31..8561e00 100644
--- a/src/Providers/Shoots.Providers.Bridge/BridgeAiDecisionProvider.cs
+++ b/src/Providers/Shoots.Providers.Bridge/BridgeAiDecisionProvider.cs
@@ -19,13 +19,13 @@ public sealed class BridgeAiDecisionProvider : IAiDecisionProvider
         _providerId = providerId;
     }
 
-    public ToolSelectionDecision? RequestDecision(AiDecisionRequest request)
+    public RouteDecision? RequestDecision(AiDecisionRequest request)
     {
         if (request is null)
             throw new ArgumentNullException(nameof(request));
 
         var step = request.Step;
-        if (step.Intent != RouteIntent.SelectTool || step.Owner != DecisionOwner.Ai)
+        if (step.Owner != DecisionOwner.Ai)
             return null;
 
         var adapter = _registry.Get(_providerId);
@@ -35,6 +35,8 @@ public sealed class BridgeAiDecisionProvider : IAiDecisionProvider
         return adapter.RequestDecision(
             request.WorkOrder,
             step,
+            request.NodeKind,
+            request.AllowedNextNodes,
             request.CatalogHash ?? string.Empty,
             string.Empty);
     }
diff --git a/src/Providers/Shoots.Providers.Fake/FakeAiProviderAdapter.cs b/src/Providers/Shoots.Providers.Fake/FakeAiProviderAdapter.cs
index b165e97..36b6df4 100644
--- a/src/Providers/Shoots.Providers.Fake/FakeAiProviderAdapter.cs
+++ b/src/Providers/Shoots.Providers.Fake/FakeAiProviderAdapter.cs
@@ -7,13 +7,26 @@ namespace Shoots.Providers.Fake;
 
 public sealed class FakeAiProviderAdapter : IAiProviderAdapter
 {
-    public ToolSelectionDecision? RequestDecision(
+    public RouteDecision? RequestDecision(
         WorkOrder workOrder,
         RouteStep step,
+        MermaidNodeKind nodeKind,
+        IReadOnlyList<string> allowedNextNodes,
         string catalogHash,
         string routingTraceSummary)
     {
-        var bindings = new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase);
-        return new ToolSelectionDecision(new ToolId("filesystem.read"), bindings);
+        if (allowedNextNodes.Count == 0)
+            return null;
+
+        var nextNodeId = allowedNextNodes[0];
+        ToolSelectionDecision? toolSelection = null;
+
+        if (step.Intent == RouteIntent.SelectTool)
+        {
+            var bindings = new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase);
+            toolSelection = new ToolSelectionDecision(new ToolId("filesystem.read"), bindings);
+        }
+
+        return new RouteDecision(nextNodeId, toolSelection);
     }
 }
diff --git a/src/Providers/Shoots.Providers.Null/NullAiProviderAdapter.cs b/src/Providers/Shoots.Providers.Null/NullAiProviderAdapter.cs
index cdcb699..67eb4a5 100644
--- a/src/Providers/Shoots.Providers.Null/NullAiProviderAdapter.cs
+++ b/src/Providers/Shoots.Providers.Null/NullAiProviderAdapter.cs
@@ -1,4 +1,5 @@
 using System;
+using System.Collections.Generic;
 using Shoots.Contracts.Core;
 using Shoots.Providers.Abstractions;
 
@@ -8,9 +9,11 @@ public sealed class NullAiProviderAdapter : IAiProviderAdapter
 {
     public static readonly NullAiProviderAdapter Instance = new();
 
-    public ToolSelectionDecision? RequestDecision(
+    public RouteDecision? RequestDecision(
         WorkOrder workOrder,
         RouteStep step,
+        MermaidNodeKind nodeKind,
+        IReadOnlyList<string> allowedNextNodes,
         string catalogHash,
         string routingTraceSummary)
     {
diff --git a/src/Runtime/Shoots.Runtime.Abstractions/AiDecisionRequest.cs b/src/Runtime/Shoots.Runtime.Abstractions/AiDecisionRequest.cs
index eb6902e..c851248 100644
--- a/src/Runtime/Shoots.Runtime.Abstractions/AiDecisionRequest.cs
+++ b/src/Runtime/Shoots.Runtime.Abstractions/AiDecisionRequest.cs
@@ -11,5 +11,7 @@ public sealed record AiDecisionRequest(
     RouteStep Step,
     RoutingState State,
     string CatalogHash,
-    IReadOnlyList<RoutingTraceEventKind> TraceSummary
+    IReadOnlyList<RoutingTraceEventKind> TraceSummary,
+    MermaidNodeKind NodeKind,
+    IReadOnlyList<string> AllowedNextNodes
 );
diff --git a/src/Runtime/Shoots.Runtime.Abstractions/BuildPlanHasher.cs b/src/Runtime/Shoots.Runtime.Abstractions/BuildPlanHasher.cs
index b507004..5a1a7c9 100644
--- a/src/Runtime/Shoots.Runtime.Abstractions/BuildPlanHasher.cs
+++ b/src/Runtime/Shoots.Runtime.Abstractions/BuildPlanHasher.cs
@@ -13,7 +13,7 @@ namespace Shoots.Runtime.Abstractions;
 /// - request.WorkOrder fields
 /// - authority.ProviderId, authority.Kind, authority.PolicyId, authority.AllowsDelegation
 /// - request.Args ordered by key (case-insensitive), normalized key/value tokens (including plan.graph)
-/// - request.RouteRules ordered by node id (including allowed output kind)
+/// - request.RouteRules ordered by node id (including allowed output kind, node kind, and allowed next nodes)
 /// - steps ordered as provided (id + description, plus AI prompt/schema when present)
 /// - tool steps include tool id + normalized input bindings + declared outputs
 /// - route steps include node id + intent + owner + work order id
@@ -97,8 +97,19 @@ public static class BuildPlanHasher
               .Append(rule.Intent.ToString())
               .Append(':')
               .Append(rule.Owner.ToString())
+              .Append(':')
+              .Append(rule.NodeKind.ToString())
               .Append('=')
               .Append(NormalizeToken(rule.AllowedOutputKind));
+
+            foreach (var nextNode in rule.AllowedNextNodes
+                         .OrderBy(node => node, StringComparer.Ordinal))
+            {
+                sb.Append("|route.edge=")
+                  .Append(NormalizeToken(rule.NodeId))
+                  .Append("->")
+                  .Append(NormalizeToken(nextNode));
+            }
         }
 
         foreach (var step in steps)
diff --git a/src/Runtime/Shoots.Runtime.Abstractions/IAiDecisionProvider.cs b/src/Runtime/Shoots.Runtime.Abstractions/IAiDecisionProvider.cs
index 3e6bbd2..843cc89 100644
--- a/src/Runtime/Shoots.Runtime.Abstractions/IAiDecisionProvider.cs
+++ b/src/Runtime/Shoots.Runtime.Abstractions/IAiDecisionProvider.cs
@@ -4,5 +4,5 @@ namespace Shoots.Runtime.Abstractions;
 
 public interface IAiDecisionProvider
 {
-    ToolSelectionDecision? RequestDecision(AiDecisionRequest request);
+    RouteDecision? RequestDecision(AiDecisionRequest request);
 }
diff --git a/src/Runtime/Shoots.Runtime.Abstractions/IRuntimeNarrator.cs b/src/Runtime/Shoots.Runtime.Abstractions/IRuntimeNarrator.cs
index a844e88..6d4f597 100644
--- a/src/Runtime/Shoots.Runtime.Abstractions/IRuntimeNarrator.cs
+++ b/src/Runtime/Shoots.Runtime.Abstractions/IRuntimeNarrator.cs
@@ -11,8 +11,12 @@ public interface IRuntimeNarrator
     void OnRoute(RouteNarration narration);
     void OnWorkOrderReceived(WorkOrder workOrder);
     void OnRouteEntered(RoutingState state, RouteStep step);
+    void OnNodeEntered(RoutingState state, RouteStep step);
     void OnDecisionRequired(RoutingState state, RouteStep step);
     void OnDecisionAccepted(RoutingState state, RouteStep step);
+    void OnNodeTransitionChosen(RoutingState state, RouteStep step, string nextNodeId);
+    void OnNodeAdvanced(RoutingState state, RouteStep step, string nextNodeId);
+    void OnNodeHalted(RoutingState state, RouteStep step, RuntimeError error);
     void OnHalted(RoutingState state, RuntimeError error);
     void OnCompleted(RoutingState state, RouteStep step);
 }
diff --git a/src/Runtime/Shoots.Runtime.Abstractions/RouteGate.cs b/src/Runtime/Shoots.Runtime.Abstractions/RouteGate.cs
index a154bc3..7f7cd3a 100644
--- a/src/Runtime/Shoots.Runtime.Abstractions/RouteGate.cs
+++ b/src/Runtime/Shoots.Runtime.Abstractions/RouteGate.cs
@@ -1,4 +1,5 @@
 using System;
+using System.Collections.Generic;
 using System.Linq;
 using Shoots.Contracts.Core;
 
@@ -11,7 +12,7 @@ public static class RouteGate
     public static bool TryAdvance(
         BuildPlan plan,
         RoutingState state,
-        ToolSelectionDecision? decision,
+        RouteDecision? decision,
         IToolRegistry registry,
         out RoutingState nextState,
         out RuntimeError? error)
@@ -103,6 +104,7 @@ public static class RouteGate
             narrator?.OnWorkOrderReceived(plan.Request.WorkOrder);
 
         narrator?.OnRouteEntered(state, routeStep);
+        narrator?.OnNodeEntered(state, routeStep);
 
         if (state.CurrentRouteIndex == 0 && routeStep.Intent == RouteIntent.Terminate)
         {
@@ -111,6 +113,7 @@ public static class RouteGate
                 "First route step cannot be terminate.",
                 routeStep.NodeId);
             nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnNodeHalted(state, routeStep, error);
             narrator?.OnHalted(nextState, error);
             return false;
         }
@@ -122,6 +125,7 @@ public static class RouteGate
                 "Route step work order does not match plan work order.",
                 new { routeStep = routeStep.WorkOrderId.Value, plan = plan.Request.WorkOrder.Id.Value });
             nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnNodeHalted(state, routeStep, error);
             narrator?.OnHalted(nextState, error);
             return false;
         }
@@ -135,6 +139,7 @@ public static class RouteGate
                 "Route rule is missing for the current node.",
                 routeStep.NodeId);
             nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnNodeHalted(state, routeStep, error);
             narrator?.OnHalted(nextState, error);
             return false;
         }
@@ -146,6 +151,57 @@ public static class RouteGate
                 "Route step does not match route rule.",
                 new { rule.Intent, rule.Owner, routeStep.Intent, routeStep.Owner });
             nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnNodeHalted(state, routeStep, error);
+            narrator?.OnHalted(nextState, error);
+            return false;
+        }
+
+        if (state.CurrentRouteIndex == 0 && rule.NodeKind != MermaidNodeKind.Start)
+        {
+            error = new RuntimeError(
+                "route_start_node_invalid",
+                "First route step must be a Start node.",
+                routeStep.NodeId);
+            nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnNodeHalted(state, routeStep, error);
+            narrator?.OnHalted(nextState, error);
+            return false;
+        }
+
+        if (state.CurrentRouteIndex != 0 && rule.NodeKind == MermaidNodeKind.Start)
+        {
+            error = new RuntimeError(
+                "route_start_node_misplaced",
+                "Start node can only appear at the first route step.",
+                routeStep.NodeId);
+            nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnNodeHalted(state, routeStep, error);
+            narrator?.OnHalted(nextState, error);
+            return false;
+        }
+
+        var allowedNextNodes = rule.AllowedNextNodes ?? Array.Empty<string>();
+
+        if (rule.NodeKind == MermaidNodeKind.Terminate && allowedNextNodes.Count > 0)
+        {
+            error = new RuntimeError(
+                "route_terminal_outbound",
+                "Terminate nodes cannot have outbound edges.",
+                routeStep.NodeId);
+            nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnNodeHalted(state, routeStep, error);
+            narrator?.OnHalted(nextState, error);
+            return false;
+        }
+
+        if (rule.NodeKind != MermaidNodeKind.Terminate && allowedNextNodes.Count == 0)
+        {
+            error = new RuntimeError(
+                "route_outbound_missing",
+                "Non-terminal nodes must declare at least one outbound edge.",
+                routeStep.NodeId);
+            nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnNodeHalted(state, routeStep, error);
             narrator?.OnHalted(nextState, error);
             return false;
         }
@@ -157,6 +213,7 @@ public static class RouteGate
             if (!ToolAuthorityValidator.TryValidateSnapshot(plan, snapshot, out error))
             {
                 nextState = state with { Status = RoutingStatus.Halted };
+                narrator?.OnNodeHalted(state, routeStep, error ?? RuntimeError.Internal("Tool authority validation failed"));
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
@@ -169,6 +226,7 @@ public static class RouteGate
                 "Routing state intent does not match current route step.",
                 new { state.CurrentRouteIntent, routeStep.Intent });
             nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnNodeHalted(state, routeStep, error);
             narrator?.OnHalted(nextState, error);
             return false;
         }
@@ -182,6 +240,7 @@ public static class RouteGate
                     "Tool invocation is only allowed for SelectTool intent.",
                     routeStep.NodeId);
                 nextState = state with { Status = RoutingStatus.Halted };
+                narrator?.OnNodeHalted(state, routeStep, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
@@ -193,17 +252,19 @@ public static class RouteGate
                     "Tool invocation work order does not match routing state.",
                     new { invocation = routeStep.ToolInvocation.WorkOrderId.Value, state = state.WorkOrderId.Value });
                 nextState = state with { Status = RoutingStatus.Halted };
+                narrator?.OnNodeHalted(state, routeStep, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
 
-            if (decision is not null && decision.ToolId != routeStep.ToolInvocation.ToolId)
+            if (decision?.ToolSelection is not null && decision.ToolSelection.ToolId != routeStep.ToolInvocation.ToolId)
             {
                 error = new RuntimeError(
                     "route_tool_invocation_conflict",
                     "Decision tool does not match route tool invocation.",
-                    new { decision = decision.ToolId.Value, invocation = routeStep.ToolInvocation.ToolId.Value });
+                    new { decision = decision.ToolSelection.ToolId.Value, invocation = routeStep.ToolInvocation.ToolId.Value });
                 nextState = state with { Status = RoutingStatus.Halted };
+                narrator?.OnNodeHalted(state, routeStep, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
@@ -217,17 +278,30 @@ public static class RouteGate
                     "route_owner_invalid",
                     "SelectTool intent requires Ai decision ownership.");
                 nextState = state with { Status = RoutingStatus.Halted };
+                narrator?.OnNodeHalted(state, routeStep, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
 
-            var effectiveDecision = decision
+            var effectiveDecision = decision?.ToolSelection
                 ?? (routeStep.ToolInvocation is null
                     ? null
                     : new ToolSelectionDecision(routeStep.ToolInvocation.ToolId, routeStep.ToolInvocation.Bindings));
 
             if (effectiveDecision is null)
             {
+                if (decision is not null)
+                {
+                    error = new RuntimeError(
+                        "route_tool_decision_missing",
+                        "Tool selection decision is required for SelectTool intent.",
+                        routeStep.NodeId);
+                    nextState = state with { Status = RoutingStatus.Halted };
+                    narrator?.OnNodeHalted(state, routeStep, error);
+                    narrator?.OnHalted(nextState, error);
+                    return false;
+                }
+
                 nextState = state with { Status = RoutingStatus.Waiting };
                 narrator?.OnDecisionRequired(nextState, routeStep);
                 error = null;
@@ -237,6 +311,7 @@ public static class RouteGate
             if (!TryValidateToolSelection(plan, snapshot, effectiveDecision, out error))
             {
                 nextState = state with { Status = RoutingStatus.Halted };
+                narrator?.OnNodeHalted(state, routeStep, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
@@ -245,27 +320,40 @@ public static class RouteGate
         }
         else
         {
-            if (decision is not null)
+            if (decision?.ToolSelection is not null)
             {
                 error = new RuntimeError(
                     "route_decision_unexpected",
                     "Decision output is only allowed for SelectTool intent.");
                 nextState = state with { Status = RoutingStatus.Halted };
+                narrator?.OnNodeHalted(state, routeStep, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
         }
 
-        var isTerminalStep = state.CurrentRouteIndex >= plan.Steps.Count - 1;
-        if (routeStep.Intent == RouteIntent.Terminate)
+        if (allowedNextNodes.Count == 0)
         {
-            if (!isTerminalStep)
+            if (routeStep.Intent != RouteIntent.Terminate)
             {
                 error = new RuntimeError(
-                    "route_terminate_not_terminal",
-                    "Terminate intent must be at a terminal route step.",
+                    "route_terminal_missing",
+                    "Terminal route step must use Terminate intent.",
                     routeStep.NodeId);
                 nextState = state with { Status = RoutingStatus.Halted };
+                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnHalted(nextState, error);
+                return false;
+            }
+
+            if (decision is not null)
+            {
+                error = new RuntimeError(
+                    "route_decision_unexpected",
+                    "Decision output is not allowed for terminal nodes.",
+                    routeStep.NodeId);
+                nextState = state with { Status = RoutingStatus.Halted };
+                narrator?.OnNodeHalted(state, routeStep, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
@@ -276,25 +364,85 @@ public static class RouteGate
             return true;
         }
 
-        if (isTerminalStep)
+        string? nextNodeId = null;
+
+        if (allowedNextNodes.Count == 1)
         {
-            error = new RuntimeError(
-                "route_terminal_missing",
-                "Terminal route step must use Terminate intent.",
-                routeStep.NodeId);
-            nextState = state with { Status = RoutingStatus.Halted };
-            narrator?.OnHalted(nextState, error);
-            return false;
+            if (decision is not null && !string.IsNullOrWhiteSpace(decision.NextNodeId) &&
+                !string.Equals(decision.NextNodeId, allowedNextNodes[0], StringComparison.Ordinal))
+            {
+                error = new RuntimeError(
+                    "route_next_node_invalid",
+                    "Decision next node is not allowed.",
+                    new { decision = decision.NextNodeId, allowed = allowedNextNodes[0] });
+                nextState = state with { Status = RoutingStatus.Halted };
+                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnHalted(nextState, error);
+                return false;
+            }
+
+            nextNodeId = allowedNextNodes[0];
         }
+        else
+        {
+            if (decision is null)
+            {
+                if (routeStep.Owner == DecisionOwner.Ai)
+                {
+                    nextState = state with { Status = RoutingStatus.Waiting };
+                    narrator?.OnDecisionRequired(nextState, routeStep);
+                    error = null;
+                    return false;
+                }
+
+                error = new RuntimeError(
+                    "route_decision_missing",
+                    "Decision is required to choose the next node.",
+                    routeStep.NodeId);
+                nextState = state with { Status = RoutingStatus.Halted };
+                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnHalted(nextState, error);
+                return false;
+            }
 
-        var nextIndex = state.CurrentRouteIndex + 1;
-        if (nextIndex >= plan.Steps.Count || plan.Steps[nextIndex] is not RouteStep nextStep)
+            if (string.IsNullOrWhiteSpace(decision.NextNodeId))
+            {
+                error = new RuntimeError(
+                    "route_next_node_missing",
+                    "Decision must include next node id.",
+                    routeStep.NodeId);
+                nextState = state with { Status = RoutingStatus.Halted };
+                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnHalted(nextState, error);
+                return false;
+            }
+
+            if (!allowedNextNodes.Any(node => string.Equals(node, decision.NextNodeId, StringComparison.Ordinal)))
+            {
+                error = new RuntimeError(
+                    "route_next_node_invalid",
+                    "Decision next node is not allowed.",
+                    new { decision = decision.NextNodeId, allowed = allowedNextNodes });
+                nextState = state with { Status = RoutingStatus.Halted };
+                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnHalted(nextState, error);
+                return false;
+            }
+
+            nextNodeId = decision.NextNodeId;
+        }
+
+        narrator?.OnNodeTransitionChosen(state, routeStep, nextNodeId);
+
+        var nextIndex = FindRouteStepIndex(plan.Steps, nextNodeId);
+        if (nextIndex < 0 || plan.Steps[nextIndex] is not RouteStep nextStep)
         {
             error = new RuntimeError(
                 "route_step_invalid",
                 "Next route step is invalid.",
-                nextIndex);
+                nextNodeId);
             nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnNodeHalted(state, routeStep, error);
             narrator?.OnHalted(nextState, error);
             return false;
         }
@@ -305,10 +453,27 @@ public static class RouteGate
             CurrentRouteIntent = nextStep.Intent,
             Status = RoutingStatus.Pending
         };
+        narrator?.OnNodeAdvanced(nextState, routeStep, nextNodeId);
         error = null;
         return true;
     }
 
+    private static int FindRouteStepIndex(
+        IReadOnlyList<BuildStep> steps,
+        string nodeId)
+    {
+        for (var index = 0; index < steps.Count; index++)
+        {
+            if (steps[index] is RouteStep step &&
+                string.Equals(step.NodeId, nodeId, StringComparison.Ordinal))
+            {
+                return index;
+            }
+        }
+
+        return -1;
+    }
+
     private static bool TryValidateToolSelection(
         BuildPlan plan,
         IReadOnlyList<ToolRegistryEntry> snapshot,
diff --git a/src/Runtime/Shoots.Runtime.Abstractions/RoutingTrace.cs b/src/Runtime/Shoots.Runtime.Abstractions/RoutingTrace.cs
index 7af8cad..74c8756 100644
--- a/src/Runtime/Shoots.Runtime.Abstractions/RoutingTrace.cs
+++ b/src/Runtime/Shoots.Runtime.Abstractions/RoutingTrace.cs
@@ -30,8 +30,12 @@ public enum RoutingTraceEventKind
     Route,
     WorkOrderReceived,
     RouteEntered,
+    NodeEntered,
     DecisionRequired,
     DecisionAccepted,
+    NodeTransitionChosen,
+    NodeAdvanced,
+    NodeHalted,
     DecisionRejected,
     ToolExecuted,
     ToolResult,
diff --git a/src/Runtime/Shoots.Runtime.Core/NullAiDecisionProvider.cs b/src/Runtime/Shoots.Runtime.Core/NullAiDecisionProvider.cs
index 598afbb..c8194f2 100644
--- a/src/Runtime/Shoots.Runtime.Core/NullAiDecisionProvider.cs
+++ b/src/Runtime/Shoots.Runtime.Core/NullAiDecisionProvider.cs
@@ -1,4 +1,5 @@
 using System;
+using Shoots.Contracts.Core;
 using Shoots.Runtime.Abstractions;
 
 namespace Shoots.Runtime.Core;
@@ -7,7 +8,7 @@ public sealed class NullAiDecisionProvider : IAiDecisionProvider
 {
     public static readonly NullAiDecisionProvider Instance = new();
 
-    public ToolSelectionDecision? RequestDecision(AiDecisionRequest request)
+    public RouteDecision? RequestDecision(AiDecisionRequest request)
     {
         _ = request ?? throw new ArgumentNullException(nameof(request));
 
diff --git a/src/Runtime/Shoots.Runtime.Core/NullRuntimeNarrator.cs b/src/Runtime/Shoots.Runtime.Core/NullRuntimeNarrator.cs
index 4309fb8..bbcad74 100644
--- a/src/Runtime/Shoots.Runtime.Core/NullRuntimeNarrator.cs
+++ b/src/Runtime/Shoots.Runtime.Core/NullRuntimeNarrator.cs
@@ -48,6 +48,12 @@ public sealed class NullRuntimeNarrator : IRuntimeNarrator
         if (step is null) throw new ArgumentNullException(nameof(step));
     }
 
+    public void OnNodeEntered(RoutingState state, RouteStep step)
+    {
+        if (state is null) throw new ArgumentNullException(nameof(state));
+        if (step is null) throw new ArgumentNullException(nameof(step));
+    }
+
     public void OnDecisionRequired(RoutingState state, RouteStep step)
     {
         if (state is null) throw new ArgumentNullException(nameof(state));
@@ -60,6 +66,27 @@ public sealed class NullRuntimeNarrator : IRuntimeNarrator
         if (step is null) throw new ArgumentNullException(nameof(step));
     }
 
+    public void OnNodeTransitionChosen(RoutingState state, RouteStep step, string nextNodeId)
+    {
+        if (state is null) throw new ArgumentNullException(nameof(state));
+        if (step is null) throw new ArgumentNullException(nameof(step));
+        if (nextNodeId is null) throw new ArgumentNullException(nameof(nextNodeId));
+    }
+
+    public void OnNodeAdvanced(RoutingState state, RouteStep step, string nextNodeId)
+    {
+        if (state is null) throw new ArgumentNullException(nameof(state));
+        if (step is null) throw new ArgumentNullException(nameof(step));
+        if (nextNodeId is null) throw new ArgumentNullException(nameof(nextNodeId));
+    }
+
+    public void OnNodeHalted(RoutingState state, RouteStep step, RuntimeError error)
+    {
+        if (state is null) throw new ArgumentNullException(nameof(state));
+        if (step is null) throw new ArgumentNullException(nameof(step));
+        if (error is null) throw new ArgumentNullException(nameof(error));
+    }
+
     public void OnHalted(RoutingState state, RuntimeError error)
     {
         if (state is null) throw new ArgumentNullException(nameof(state));
diff --git a/src/Runtime/Shoots.Runtime.Core/RoutingLoop.cs b/src/Runtime/Shoots.Runtime.Core/RoutingLoop.cs
index 18d70a1..d404dd2 100644
--- a/src/Runtime/Shoots.Runtime.Core/RoutingLoop.cs
+++ b/src/Runtime/Shoots.Runtime.Core/RoutingLoop.cs
@@ -100,9 +100,9 @@ public sealed class RoutingLoop
                 if (step.Intent == RouteIntent.SelectTool)
                 {
                     var invocation = step.ToolInvocation
-                                     ?? (decision is null
+                                     ?? (decision?.ToolSelection is null
                                          ? null
-                                         : new ToolInvocation(decision.ToolId, decision.Bindings, State.WorkOrderId));
+                                         : new ToolInvocation(decision.ToolSelection.ToolId, decision.ToolSelection.Bindings, State.WorkOrderId));
 
                     if (invocation is not null)
                     {
@@ -137,7 +137,7 @@ public sealed class RoutingLoop
         return new RoutingLoopResult(State, _toolResults.ToArray(), _traceBuilder.Build(), _traceBuilder.BuildTelemetry());
     }
 
-    private ToolSelectionDecision? ResolveDecision(RouteStep step)
+    private RouteDecision? ResolveDecision(RouteStep step)
     {
         if (State.Status != RoutingStatus.Waiting)
             return null;
@@ -146,7 +146,11 @@ public sealed class RoutingLoop
             .Entries
             .Select(entry => entry.Event)
             .ToArray();
-        var request = new AiDecisionRequest(_plan.Request.WorkOrder!, step, State, _catalogHash, summary);
+        var rule = _plan.Request.RouteRules
+            .FirstOrDefault(candidate => string.Equals(candidate.NodeId, step.NodeId, StringComparison.Ordinal));
+        var nodeKind = rule?.NodeKind ?? MermaidNodeKind.Linear;
+        var allowedNextNodes = rule?.AllowedNextNodes ?? Array.Empty<string>();
+        var request = new AiDecisionRequest(_plan.Request.WorkOrder!, step, State, _catalogHash, summary, nodeKind, allowedNextNodes);
         return _aiDecisionProvider.RequestDecision(request);
     }
 
diff --git a/src/Runtime/Shoots.Runtime.Core/TracingRuntimeNarrator.cs b/src/Runtime/Shoots.Runtime.Core/TracingRuntimeNarrator.cs
index b0e80a3..a5cd9ce 100644
--- a/src/Runtime/Shoots.Runtime.Core/TracingRuntimeNarrator.cs
+++ b/src/Runtime/Shoots.Runtime.Core/TracingRuntimeNarrator.cs
@@ -58,6 +58,12 @@ internal sealed class TracingRuntimeNarrator : IRuntimeNarrator
         _inner.OnRouteEntered(state, step);
     }
 
+    public void OnNodeEntered(RoutingState state, RouteStep step)
+    {
+        _trace.Add(RoutingTraceEventKind.NodeEntered, step.NodeId, state, step);
+        _inner.OnNodeEntered(state, step);
+    }
+
     public void OnDecisionRequired(RoutingState state, RouteStep step)
     {
         _trace.Add(RoutingTraceEventKind.DecisionRequired, step.NodeId, state, step);
@@ -70,6 +76,24 @@ internal sealed class TracingRuntimeNarrator : IRuntimeNarrator
         _inner.OnDecisionAccepted(state, step);
     }
 
+    public void OnNodeTransitionChosen(RoutingState state, RouteStep step, string nextNodeId)
+    {
+        _trace.Add(RoutingTraceEventKind.NodeTransitionChosen, $"{step.NodeId}->{nextNodeId}", state, step);
+        _inner.OnNodeTransitionChosen(state, step, nextNodeId);
+    }
+
+    public void OnNodeAdvanced(RoutingState state, RouteStep step, string nextNodeId)
+    {
+        _trace.Add(RoutingTraceEventKind.NodeAdvanced, $"{step.NodeId}->{nextNodeId}", state, step);
+        _inner.OnNodeAdvanced(state, step, nextNodeId);
+    }
+
+    public void OnNodeHalted(RoutingState state, RouteStep step, RuntimeError error)
+    {
+        _trace.Add(RoutingTraceEventKind.NodeHalted, error.Code, state, step, error);
+        _inner.OnNodeHalted(state, step, error);
+    }
+
     public void OnHalted(RoutingState state, RuntimeError error)
     {
         _trace.Add(RoutingTraceEventKind.Halted, error.Code, state, error: error);
diff --git a/src/Runtime/Shoots.Runtime.Tests/RouteGateTests.cs b/src/Runtime/Shoots.Runtime.Tests/RouteGateTests.cs
index 5594370..bc12fc9 100644
--- a/src/Runtime/Shoots.Runtime.Tests/RouteGateTests.cs
+++ b/src/Runtime/Shoots.Runtime.Tests/RouteGateTests.cs
@@ -15,8 +15,8 @@ public sealed class RouteGateTests
             new WorkOrderId("wo-plan"),
             new[]
             {
-                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation"),
-                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation", MermaidNodeKind.Start, new[] { "terminate" }),
+                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>())
             });
 
         var state = new RoutingState(
@@ -40,8 +40,8 @@ public sealed class RouteGateTests
             new WorkOrderId("wo-plan"),
             new[]
             {
-                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection"),
-                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection", MermaidNodeKind.Start, new[] { "terminate" }),
+                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>())
             });
 
         var state = RoutingState.CreateInitial(plan);
@@ -61,14 +61,16 @@ public sealed class RouteGateTests
             new WorkOrderId("wo-plan"),
             new[]
             {
-                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation"),
-                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation", MermaidNodeKind.Start, new[] { "terminate" }),
+                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>())
             });
 
         var state = RoutingState.CreateInitial(plan);
-        var decision = new ToolSelectionDecision(
-            new ToolId("tools.any"),
-            new Dictionary<string, object?>());
+        var decision = new RouteDecision(
+            "terminate",
+            new ToolSelectionDecision(
+                new ToolId("tools.any"),
+                new Dictionary<string, object?>()));
 
         var result = RouteGate.TryAdvance(plan, state, decision, new StubToolRegistry(), out var nextState, out var error);
 
@@ -93,9 +95,9 @@ public sealed class RouteGateTests
             new WorkOrderId("wo-plan"),
             new[]
             {
-                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection"),
-                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation"),
-                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection", MermaidNodeKind.Start, new[] { "validate" }),
+                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation", MermaidNodeKind.Linear, new[] { "terminate" }),
+                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>())
             });
 
         var narrator = new RecordingNarrator();
@@ -106,7 +108,9 @@ public sealed class RouteGateTests
             var registry = new SnapshotOnlyRegistry(toolSpec);
             var state = RoutingState.CreateInitial(plan);
 
-            var decision = new ToolSelectionDecision(toolSpec.ToolId, new Dictionary<string, object?>());
+            var decision = new RouteDecision(
+                "validate",
+                new ToolSelectionDecision(toolSpec.ToolId, new Dictionary<string, object?>()));
             var advanced = RouteGate.TryAdvance(plan, state, decision, registry, out var nextState, out var error);
 
             Assert.True(advanced);
@@ -132,12 +136,14 @@ public sealed class RouteGateTests
             new WorkOrderId("wo-plan"),
             new[]
             {
-                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation"),
-                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation", MermaidNodeKind.Start, new[] { "terminate" }),
+                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>())
             });
 
         var state = RoutingState.CreateInitial(plan);
-        var decision = new ToolSelectionDecision(new ToolId("tools.any"), new Dictionary<string, object?>());
+        var decision = new RouteDecision(
+            "terminate",
+            new ToolSelectionDecision(new ToolId("tools.any"), new Dictionary<string, object?>()));
 
         var result = RouteGate.TryAdvance(plan, state, decision, new SnapshotOnlyRegistry(), out var nextState, out var error);
 
@@ -154,9 +160,9 @@ public sealed class RouteGateTests
             new WorkOrderId("wo-plan"),
             new[]
             {
-                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection"),
-                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation"),
-                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection", MermaidNodeKind.Start, new[] { "validate" }),
+                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation", MermaidNodeKind.Linear, new[] { "terminate" }),
+                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>())
             });
 
         var lateState = new RoutingState(
@@ -164,7 +170,9 @@ public sealed class RouteGateTests
             1,
             RouteIntent.Validate,
             RoutingStatus.Pending);
-        var decision = new ToolSelectionDecision(new ToolId("tools.any"), new Dictionary<string, object?>());
+        var decision = new RouteDecision(
+            "terminate",
+            new ToolSelectionDecision(new ToolId("tools.any"), new Dictionary<string, object?>()));
 
         var result = RouteGate.TryAdvance(plan, lateState, decision, new SnapshotOnlyRegistry(), out var nextState, out var error);
 
@@ -189,8 +197,8 @@ public sealed class RouteGateTests
             new WorkOrderId("wo-plan"),
             new[]
             {
-                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection"),
-                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection", MermaidNodeKind.Start, new[] { "terminate" }),
+                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>())
             });
 
         var registry = new SnapshotOnlyRegistry(toolSpec)
@@ -198,7 +206,9 @@ public sealed class RouteGateTests
             LiveMissing = true
         };
         var state = RoutingState.CreateInitial(plan);
-        var decision = new ToolSelectionDecision(toolSpec.ToolId, new Dictionary<string, object?>());
+        var decision = new RouteDecision(
+            "terminate",
+            new ToolSelectionDecision(toolSpec.ToolId, new Dictionary<string, object?>()));
 
         var result = RouteGate.TryAdvance(plan, state, decision, registry, out var nextState, out var error);
 
@@ -214,8 +224,8 @@ public sealed class RouteGateTests
             new WorkOrderId("wo-plan"),
             new[]
             {
-                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation"),
-                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation", MermaidNodeKind.Start, new[] { "terminate" }),
+                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>())
             });
 
         var narrator = new RecordingNarrator();
@@ -257,14 +267,16 @@ public sealed class RouteGateTests
             new WorkOrderId("wo-plan"),
             new[]
             {
-                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection"),
-                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection", MermaidNodeKind.Start, new[] { "terminate" }),
+                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>())
             });
 
         var registry = new SnapshotOnlyRegistry(toolSpec);
         var state = RoutingState.CreateInitial(plan);
 
-        var decision = new ToolSelectionDecision(toolSpec.ToolId, new Dictionary<string, object?>());
+        var decision = new RouteDecision(
+            "terminate",
+            new ToolSelectionDecision(toolSpec.ToolId, new Dictionary<string, object?>()));
         var advanced = RouteGate.TryAdvance(plan, state, decision, registry, out var nextState, out var error);
 
         Assert.True(advanced);
@@ -288,12 +300,14 @@ public sealed class RouteGateTests
             new WorkOrderId("wo-plan"),
             new[]
             {
-                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Human, "tool.selection"),
-                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Human, "tool.selection", MermaidNodeKind.Start, new[] { "terminate" }),
+                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>())
             });
 
         var state = RoutingState.CreateInitial(plan);
-        var decision = new ToolSelectionDecision(new ToolId("tools.any"), new Dictionary<string, object?>());
+        var decision = new RouteDecision(
+            "terminate",
+            new ToolSelectionDecision(new ToolId("tools.any"), new Dictionary<string, object?>()));
 
         var result = RouteGate.TryAdvance(plan, state, decision, new SnapshotOnlyRegistry(), out var nextState, out var error);
 
@@ -310,8 +324,8 @@ public sealed class RouteGateTests
             new WorkOrderId("wo-plan"),
             new[]
             {
-                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection"),
-                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection", MermaidNodeKind.Start, new[] { "terminate" }),
+                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>())
             });
 
         var state = new RoutingState(
@@ -319,7 +333,9 @@ public sealed class RouteGateTests
             0,
             RouteIntent.SelectTool,
             RoutingStatus.Pending);
-        var decision = new ToolSelectionDecision(new ToolId("tools.any"), new Dictionary<string, object?>());
+        var decision = new RouteDecision(
+            "terminate",
+            new ToolSelectionDecision(new ToolId("tools.any"), new Dictionary<string, object?>()));
 
         var result = RouteGate.TryAdvance(plan, state, decision, new SnapshotOnlyRegistry(), out var nextState, out var error);
 
@@ -341,8 +357,8 @@ public sealed class RouteGateTests
             new WorkOrderId("wo-plan"),
             new[]
             {
-                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation"),
-                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+                new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation", MermaidNodeKind.Start, new[] { "terminate" }),
+                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>())
             },
             toolResult);
 
@@ -448,8 +464,12 @@ public sealed class RouteGateTests
         public void OnRoute(RouteNarration narration) => Events.Add("route");
         public void OnWorkOrderReceived(WorkOrder workOrder) => Events.Add("workorder");
         public void OnRouteEntered(RoutingState state, RouteStep step) => Events.Add("entered");
+        public void OnNodeEntered(RoutingState state, RouteStep step) => Events.Add("node.entered");
         public void OnDecisionRequired(RoutingState state, RouteStep step) => Events.Add("decision.required");
         public void OnDecisionAccepted(RoutingState state, RouteStep step) => Events.Add("decision.accepted");
+        public void OnNodeTransitionChosen(RoutingState state, RouteStep step, string nextNodeId) => Events.Add("node.transition");
+        public void OnNodeAdvanced(RoutingState state, RouteStep step, string nextNodeId) => Events.Add("node.advanced");
+        public void OnNodeHalted(RoutingState state, RouteStep step, RuntimeError error) => Events.Add("node.halted");
         public void OnHalted(RoutingState state, RuntimeError error) => Events.Add("halted");
         public void OnCompleted(RoutingState state, RouteStep step) => Events.Add("completed");
     }
diff --git a/src/Runtime/Shoots.Runtime.Tests/RoutingLoopTests.cs b/src/Runtime/Shoots.Runtime.Tests/RoutingLoopTests.cs
index 3ee627f..747ca6a 100644
--- a/src/Runtime/Shoots.Runtime.Tests/RoutingLoopTests.cs
+++ b/src/Runtime/Shoots.Runtime.Tests/RoutingLoopTests.cs
@@ -1,3 +1,4 @@
+using System;
 using System.Collections.Generic;
 using Shoots.Contracts.Core;
 using Shoots.Runtime.Abstractions;
@@ -24,8 +25,8 @@ public sealed class RoutingLoopTests
             new Dictionary<string, object?>(),
             new[]
             {
-                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection"),
-                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection", MermaidNodeKind.Start, new[] { "terminate" }),
+                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>())
             });
 
         var steps = new BuildStep[]
@@ -88,8 +89,8 @@ public sealed class RoutingLoopTests
             new Dictionary<string, object?>(),
             new[]
             {
-                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection"),
-                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+                new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection", MermaidNodeKind.Start, new[] { "terminate" }),
+                new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>())
             });
 
         var steps = new BuildStep[]
@@ -144,17 +145,19 @@ public sealed class RoutingLoopTests
 
     private sealed class RefusingAiDecisionProvider : IAiDecisionProvider
     {
-        public ToolSelectionDecision? RequestDecision(AiDecisionRequest request) => null;
+        public RouteDecision? RequestDecision(AiDecisionRequest request) => null;
     }
 
     private sealed class AcceptingAiDecisionProvider : IAiDecisionProvider
     {
-        public ToolSelectionDecision? RequestDecision(AiDecisionRequest request)
+        public RouteDecision? RequestDecision(AiDecisionRequest request)
         {
             if (request.Step.Intent != RouteIntent.SelectTool)
                 return null;
 
-            return new ToolSelectionDecision(new ToolId("tools.sample"), new Dictionary<string, object?>());
+            return new RouteDecision(
+                "terminate",
+                new ToolSelectionDecision(new ToolId("tools.sample"), new Dictionary<string, object?>()));
         }
     }
 
diff --git a/src/Runtime/Shoots.Runtime.Tests/RoutingStateTests.cs b/src/Runtime/Shoots.Runtime.Tests/RoutingStateTests.cs
index 3f979d4..cce6877 100644
--- a/src/Runtime/Shoots.Runtime.Tests/RoutingStateTests.cs
+++ b/src/Runtime/Shoots.Runtime.Tests/RoutingStateTests.cs
@@ -12,7 +12,7 @@ public sealed class RoutingStateTests
     [Fact]
     public void CreateInitial_rejects_terminate_first_step()
     {
-        var plan = CreatePlan(new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination"));
+        var plan = CreatePlan(new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>()));
 
         Assert.Throws<ArgumentException>(() => RoutingState.CreateInitial(plan));
     }
@@ -20,7 +20,7 @@ public sealed class RoutingStateTests
     [Fact]
     public void CreateInitial_uses_supplied_workorder()
     {
-        var plan = CreatePlan(new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation"));
+        var plan = CreatePlan(new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation", MermaidNodeKind.Start, new[] { "terminate" }));
         var workOrder = new WorkOrder(
             new WorkOrderId("wo-custom"),
             "Original request.",
diff --git a/src/Runtime/Shoots.Runtime.Tests/TestRequestFactory.cs b/src/Runtime/Shoots.Runtime.Tests/TestRequestFactory.cs
index 0b8bb90..9cf6c39 100644
--- a/src/Runtime/Shoots.Runtime.Tests/TestRequestFactory.cs
+++ b/src/Runtime/Shoots.Runtime.Tests/TestRequestFactory.cs
@@ -29,10 +29,10 @@ internal static class TestRequestFactory
     {
         return new[]
         {
-            new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection"),
-            new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation"),
-            new RouteRule("review", RouteIntent.Review, DecisionOwner.Human, "review"),
-            new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination")
+            new RouteRule("select", RouteIntent.SelectTool, DecisionOwner.Ai, "tool.selection", MermaidNodeKind.Start, new[] { "validate" }),
+            new RouteRule("validate", RouteIntent.Validate, DecisionOwner.Runtime, "validation", MermaidNodeKind.Linear, new[] { "review" }),
+            new RouteRule("review", RouteIntent.Review, DecisionOwner.Human, "review", MermaidNodeKind.Linear, new[] { "terminate" }),
+            new RouteRule("terminate", RouteIntent.Terminate, DecisionOwner.Rule, "termination", MermaidNodeKind.Terminate, Array.Empty<string>())
         };
     }
 }
