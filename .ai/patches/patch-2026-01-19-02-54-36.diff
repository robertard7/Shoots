diff --git a/src/Contracts/Shoots.Contracts.Core/RouteDecision.cs b/src/Contracts/Shoots.Contracts.Core/RouteDecision.cs
index fdc394e..50db220 100644
--- a/src/Contracts/Shoots.Contracts.Core/RouteDecision.cs
+++ b/src/Contracts/Shoots.Contracts.Core/RouteDecision.cs
@@ -4,6 +4,7 @@ namespace Shoots.Contracts.Core;
 /// Deterministic routing decision payload.
 /// </summary>
 public sealed record RouteDecision(
-    string NextNodeId,
+    string SelectedNextNodeId,
+    RouteIntent ObservedIntent,
     ToolSelectionDecision? ToolSelection = null
 );
diff --git a/src/Contracts/Shoots.Contracts.Core/RouteIntentToken.cs b/src/Contracts/Shoots.Contracts.Core/RouteIntentToken.cs
new file mode 100644
index 0000000..0cdefef
--- /dev/null
+++ b/src/Contracts/Shoots.Contracts.Core/RouteIntentToken.cs
@@ -0,0 +1,11 @@
+namespace Shoots.Contracts.Core;
+
+/// <summary>
+/// Immutable intent token carried through routing decisions.
+/// </summary>
+public sealed record RouteIntentToken(
+    WorkOrderId WorkOrderId,
+    RouteIntent Intent,
+    string OriginNodeId,
+    string ConstraintsHash
+);
diff --git a/src/Providers/Shoots.Providers.Abstractions/IAiProviderAdapter.cs b/src/Providers/Shoots.Providers.Abstractions/IAiProviderAdapter.cs
index 72d0c02..cf14c46 100644
--- a/src/Providers/Shoots.Providers.Abstractions/IAiProviderAdapter.cs
+++ b/src/Providers/Shoots.Providers.Abstractions/IAiProviderAdapter.cs
@@ -10,6 +10,7 @@ public interface IAiProviderAdapter
         RouteStep step,
         MermaidNodeKind nodeKind,
         IReadOnlyList<string> allowedNextNodes,
+        RouteIntentToken intentToken,
         string catalogHash,
         string routingTraceSummary);
 }
diff --git a/src/Providers/Shoots.Providers.Bridge/BridgeAiDecisionProvider.cs b/src/Providers/Shoots.Providers.Bridge/BridgeAiDecisionProvider.cs
index 8561e00..4319068 100644
--- a/src/Providers/Shoots.Providers.Bridge/BridgeAiDecisionProvider.cs
+++ b/src/Providers/Shoots.Providers.Bridge/BridgeAiDecisionProvider.cs
@@ -37,6 +37,7 @@ public sealed class BridgeAiDecisionProvider : IAiDecisionProvider
             step,
             request.NodeKind,
             request.AllowedNextNodes,
+            request.IntentToken,
             request.CatalogHash ?? string.Empty,
             string.Empty);
     }
diff --git a/src/Providers/Shoots.Providers.Fake/FakeAiProviderAdapter.cs b/src/Providers/Shoots.Providers.Fake/FakeAiProviderAdapter.cs
index 36b6df4..3960cc1 100644
--- a/src/Providers/Shoots.Providers.Fake/FakeAiProviderAdapter.cs
+++ b/src/Providers/Shoots.Providers.Fake/FakeAiProviderAdapter.cs
@@ -12,13 +12,13 @@ public sealed class FakeAiProviderAdapter : IAiProviderAdapter
         RouteStep step,
         MermaidNodeKind nodeKind,
         IReadOnlyList<string> allowedNextNodes,
+        RouteIntentToken intentToken,
         string catalogHash,
         string routingTraceSummary)
     {
-        if (allowedNextNodes.Count == 0)
-            return null;
-
-        var nextNodeId = allowedNextNodes[0];
+        var nextNodeId = allowedNextNodes.Count == 0
+            ? string.Empty
+            : allowedNextNodes[0];
         ToolSelectionDecision? toolSelection = null;
 
         if (step.Intent == RouteIntent.SelectTool)
@@ -27,6 +27,6 @@ public sealed class FakeAiProviderAdapter : IAiProviderAdapter
             toolSelection = new ToolSelectionDecision(new ToolId("filesystem.read"), bindings);
         }
 
-        return new RouteDecision(nextNodeId, toolSelection);
+        return new RouteDecision(nextNodeId, intentToken.Intent, toolSelection);
     }
 }
diff --git a/src/Providers/Shoots.Providers.Null/NullAiProviderAdapter.cs b/src/Providers/Shoots.Providers.Null/NullAiProviderAdapter.cs
index 67eb4a5..ac4c3bc 100644
--- a/src/Providers/Shoots.Providers.Null/NullAiProviderAdapter.cs
+++ b/src/Providers/Shoots.Providers.Null/NullAiProviderAdapter.cs
@@ -14,6 +14,7 @@ public sealed class NullAiProviderAdapter : IAiProviderAdapter
         RouteStep step,
         MermaidNodeKind nodeKind,
         IReadOnlyList<string> allowedNextNodes,
+        RouteIntentToken intentToken,
         string catalogHash,
         string routingTraceSummary)
     {
diff --git a/src/Runtime/Shoots.Runtime.Abstractions/AiDecisionRequest.cs b/src/Runtime/Shoots.Runtime.Abstractions/AiDecisionRequest.cs
index c851248..de037d0 100644
--- a/src/Runtime/Shoots.Runtime.Abstractions/AiDecisionRequest.cs
+++ b/src/Runtime/Shoots.Runtime.Abstractions/AiDecisionRequest.cs
@@ -13,5 +13,6 @@ public sealed record AiDecisionRequest(
     string CatalogHash,
     IReadOnlyList<RoutingTraceEventKind> TraceSummary,
     MermaidNodeKind NodeKind,
-    IReadOnlyList<string> AllowedNextNodes
+    IReadOnlyList<string> AllowedNextNodes,
+    RouteIntentToken IntentToken
 );
diff --git a/src/Runtime/Shoots.Runtime.Abstractions/IRuntimeNarrator.cs b/src/Runtime/Shoots.Runtime.Abstractions/IRuntimeNarrator.cs
index 6d4f597..83d00df 100644
--- a/src/Runtime/Shoots.Runtime.Abstractions/IRuntimeNarrator.cs
+++ b/src/Runtime/Shoots.Runtime.Abstractions/IRuntimeNarrator.cs
@@ -1,3 +1,4 @@
+using System.Collections.Generic;
 using Shoots.Contracts.Core;
 
 namespace Shoots.Runtime.Abstractions;
@@ -10,13 +11,13 @@ public interface IRuntimeNarrator
     void OnError(RuntimeError error);
     void OnRoute(RouteNarration narration);
     void OnWorkOrderReceived(WorkOrder workOrder);
-    void OnRouteEntered(RoutingState state, RouteStep step);
-    void OnNodeEntered(RoutingState state, RouteStep step);
-    void OnDecisionRequired(RoutingState state, RouteStep step);
-    void OnDecisionAccepted(RoutingState state, RouteStep step);
-    void OnNodeTransitionChosen(RoutingState state, RouteStep step, string nextNodeId);
-    void OnNodeAdvanced(RoutingState state, RouteStep step, string nextNodeId);
-    void OnNodeHalted(RoutingState state, RouteStep step, RuntimeError error);
+    void OnRouteEntered(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes);
+    void OnNodeEntered(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes);
+    void OnDecisionRequired(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes);
+    void OnDecisionAccepted(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes);
+    void OnNodeTransitionChosen(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes, string nextNodeId);
+    void OnNodeAdvanced(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes, string nextNodeId);
+    void OnNodeHalted(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes, RuntimeError error);
     void OnHalted(RoutingState state, RuntimeError error);
-    void OnCompleted(RoutingState state, RouteStep step);
+    void OnCompleted(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes);
 }
diff --git a/src/Runtime/Shoots.Runtime.Abstractions/RouteGate.cs b/src/Runtime/Shoots.Runtime.Abstractions/RouteGate.cs
index 7f7cd3a..b124f6b 100644
--- a/src/Runtime/Shoots.Runtime.Abstractions/RouteGate.cs
+++ b/src/Runtime/Shoots.Runtime.Abstractions/RouteGate.cs
@@ -103,8 +103,26 @@ public static class RouteGate
         if (state.CurrentRouteIndex == 0 && state.Status == RoutingStatus.Pending)
             narrator?.OnWorkOrderReceived(plan.Request.WorkOrder);
 
-        narrator?.OnRouteEntered(state, routeStep);
-        narrator?.OnNodeEntered(state, routeStep);
+        if (state.IntentToken is null)
+        {
+            error = new RuntimeError(
+                "route_intent_token_missing",
+                "Intent token is required to advance routing.");
+            nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnHalted(nextState, error);
+            return false;
+        }
+
+        if (!string.Equals(state.IntentToken.WorkOrderId.Value, state.WorkOrderId.Value, StringComparison.Ordinal))
+        {
+            error = new RuntimeError(
+                "route_intent_token_workorder_mismatch",
+                "Intent token work order does not match routing state.",
+                new { token = state.IntentToken.WorkOrderId.Value, state = state.WorkOrderId.Value });
+            nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnHalted(nextState, error);
+            return false;
+        }
 
         if (state.CurrentRouteIndex == 0 && routeStep.Intent == RouteIntent.Terminate)
         {
@@ -182,6 +200,34 @@ public static class RouteGate
 
         var allowedNextNodes = rule.AllowedNextNodes ?? Array.Empty<string>();
 
+        narrator?.OnRouteEntered(state, routeStep, state.IntentToken, allowedNextNodes);
+        narrator?.OnNodeEntered(state, routeStep, state.IntentToken, allowedNextNodes);
+
+        if (!IsIntentCompatible(state.IntentToken.Intent, rule.NodeKind))
+        {
+            error = new RuntimeError(
+                "route_intent_node_kind_mismatch",
+                "Intent token does not match node kind.",
+                new { state.IntentToken.Intent, rule.NodeKind });
+            nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
+            narrator?.OnHalted(nextState, error);
+            return false;
+        }
+
+        if (state.CurrentRouteIndex == 0 &&
+            !string.Equals(state.IntentToken.OriginNodeId, routeStep.NodeId, StringComparison.Ordinal))
+        {
+            error = new RuntimeError(
+                "route_intent_origin_mismatch",
+                "Intent token origin does not match entry node.",
+                new { token = state.IntentToken.OriginNodeId, node = routeStep.NodeId });
+            nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
+            narrator?.OnHalted(nextState, error);
+            return false;
+        }
+
         if (rule.NodeKind == MermaidNodeKind.Terminate && allowedNextNodes.Count > 0)
         {
             error = new RuntimeError(
@@ -189,7 +235,7 @@ public static class RouteGate
                 "Terminate nodes cannot have outbound edges.",
                 routeStep.NodeId);
             nextState = state with { Status = RoutingStatus.Halted };
-            narrator?.OnNodeHalted(state, routeStep, error);
+            narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
             narrator?.OnHalted(nextState, error);
             return false;
         }
@@ -201,7 +247,7 @@ public static class RouteGate
                 "Non-terminal nodes must declare at least one outbound edge.",
                 routeStep.NodeId);
             nextState = state with { Status = RoutingStatus.Halted };
-            narrator?.OnNodeHalted(state, routeStep, error);
+            narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
             narrator?.OnHalted(nextState, error);
             return false;
         }
@@ -213,7 +259,7 @@ public static class RouteGate
             if (!ToolAuthorityValidator.TryValidateSnapshot(plan, snapshot, out error))
             {
                 nextState = state with { Status = RoutingStatus.Halted };
-                narrator?.OnNodeHalted(state, routeStep, error ?? RuntimeError.Internal("Tool authority validation failed"));
+                narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error ?? RuntimeError.Internal("Tool authority validation failed"));
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
@@ -226,7 +272,7 @@ public static class RouteGate
                 "Routing state intent does not match current route step.",
                 new { state.CurrentRouteIntent, routeStep.Intent });
             nextState = state with { Status = RoutingStatus.Halted };
-            narrator?.OnNodeHalted(state, routeStep, error);
+            narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
             narrator?.OnHalted(nextState, error);
             return false;
         }
@@ -240,7 +286,7 @@ public static class RouteGate
                     "Tool invocation is only allowed for SelectTool intent.",
                     routeStep.NodeId);
                 nextState = state with { Status = RoutingStatus.Halted };
-                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
@@ -252,7 +298,7 @@ public static class RouteGate
                     "Tool invocation work order does not match routing state.",
                     new { invocation = routeStep.ToolInvocation.WorkOrderId.Value, state = state.WorkOrderId.Value });
                 nextState = state with { Status = RoutingStatus.Halted };
-                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
@@ -264,7 +310,7 @@ public static class RouteGate
                     "Decision tool does not match route tool invocation.",
                     new { decision = decision.ToolSelection.ToolId.Value, invocation = routeStep.ToolInvocation.ToolId.Value });
                 nextState = state with { Status = RoutingStatus.Halted };
-                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
@@ -297,13 +343,13 @@ public static class RouteGate
                         "Tool selection decision is required for SelectTool intent.",
                         routeStep.NodeId);
                     nextState = state with { Status = RoutingStatus.Halted };
-                    narrator?.OnNodeHalted(state, routeStep, error);
+                    narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
                     narrator?.OnHalted(nextState, error);
                     return false;
                 }
 
                 nextState = state with { Status = RoutingStatus.Waiting };
-                narrator?.OnDecisionRequired(nextState, routeStep);
+                narrator?.OnDecisionRequired(nextState, routeStep, state.IntentToken, allowedNextNodes);
                 error = null;
                 return false;
             }
@@ -311,12 +357,12 @@ public static class RouteGate
             if (!TryValidateToolSelection(plan, snapshot, effectiveDecision, out error))
             {
                 nextState = state with { Status = RoutingStatus.Halted };
-                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
 
-            narrator?.OnDecisionAccepted(state, routeStep);
+            narrator?.OnDecisionAccepted(state, routeStep, state.IntentToken, allowedNextNodes);
         }
         else
         {
@@ -326,12 +372,24 @@ public static class RouteGate
                     "route_decision_unexpected",
                     "Decision output is only allowed for SelectTool intent.");
                 nextState = state with { Status = RoutingStatus.Halted };
-                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
         }
 
+        if (decision is not null && decision.ObservedIntent != state.IntentToken.Intent)
+        {
+            error = new RuntimeError(
+                "route_intent_observed_mismatch",
+                "Decision intent does not match intent token.",
+                new { decision.ObservedIntent, state.IntentToken.Intent });
+            nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
+            narrator?.OnHalted(nextState, error);
+            return false;
+        }
+
         if (allowedNextNodes.Count == 0)
         {
             if (routeStep.Intent != RouteIntent.Terminate)
@@ -341,7 +399,7 @@ public static class RouteGate
                     "Terminal route step must use Terminate intent.",
                     routeStep.NodeId);
                 nextState = state with { Status = RoutingStatus.Halted };
-                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
@@ -353,30 +411,42 @@ public static class RouteGate
                     "Decision output is not allowed for terminal nodes.",
                     routeStep.NodeId);
                 nextState = state with { Status = RoutingStatus.Halted };
-                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
 
             nextState = state with { Status = RoutingStatus.Completed };
-            narrator?.OnCompleted(nextState, routeStep);
+            narrator?.OnCompleted(nextState, routeStep, state.IntentToken, allowedNextNodes);
             error = null;
             return true;
         }
 
         string? nextNodeId = null;
 
+        if (decision is not null && string.IsNullOrWhiteSpace(decision.SelectedNextNodeId))
+        {
+            error = new RuntimeError(
+                "route_next_node_missing",
+                "Decision must include next node id.",
+                routeStep.NodeId);
+            nextState = state with { Status = RoutingStatus.Halted };
+            narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
+            narrator?.OnHalted(nextState, error);
+            return false;
+        }
+
         if (allowedNextNodes.Count == 1)
         {
-            if (decision is not null && !string.IsNullOrWhiteSpace(decision.NextNodeId) &&
-                !string.Equals(decision.NextNodeId, allowedNextNodes[0], StringComparison.Ordinal))
+            if (decision is not null &&
+                !string.Equals(decision.SelectedNextNodeId, allowedNextNodes[0], StringComparison.Ordinal))
             {
                 error = new RuntimeError(
                     "route_next_node_invalid",
                     "Decision next node is not allowed.",
-                    new { decision = decision.NextNodeId, allowed = allowedNextNodes[0] });
+                    new { decision = decision.SelectedNextNodeId, allowed = allowedNextNodes[0] });
                 nextState = state with { Status = RoutingStatus.Halted };
-                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
@@ -390,7 +460,7 @@ public static class RouteGate
                 if (routeStep.Owner == DecisionOwner.Ai)
                 {
                     nextState = state with { Status = RoutingStatus.Waiting };
-                    narrator?.OnDecisionRequired(nextState, routeStep);
+                    narrator?.OnDecisionRequired(nextState, routeStep, state.IntentToken, allowedNextNodes);
                     error = null;
                     return false;
                 }
@@ -400,39 +470,39 @@ public static class RouteGate
                     "Decision is required to choose the next node.",
                     routeStep.NodeId);
                 nextState = state with { Status = RoutingStatus.Halted };
-                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
 
-            if (string.IsNullOrWhiteSpace(decision.NextNodeId))
+            if (string.IsNullOrWhiteSpace(decision.SelectedNextNodeId))
             {
                 error = new RuntimeError(
                     "route_next_node_missing",
                     "Decision must include next node id.",
                     routeStep.NodeId);
                 nextState = state with { Status = RoutingStatus.Halted };
-                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
 
-            if (!allowedNextNodes.Any(node => string.Equals(node, decision.NextNodeId, StringComparison.Ordinal)))
+            if (!allowedNextNodes.Any(node => string.Equals(node, decision.SelectedNextNodeId, StringComparison.Ordinal)))
             {
                 error = new RuntimeError(
                     "route_next_node_invalid",
                     "Decision next node is not allowed.",
-                    new { decision = decision.NextNodeId, allowed = allowedNextNodes });
+                    new { decision = decision.SelectedNextNodeId, allowed = allowedNextNodes });
                 nextState = state with { Status = RoutingStatus.Halted };
-                narrator?.OnNodeHalted(state, routeStep, error);
+                narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
                 narrator?.OnHalted(nextState, error);
                 return false;
             }
 
-            nextNodeId = decision.NextNodeId;
+            nextNodeId = decision.SelectedNextNodeId;
         }
 
-        narrator?.OnNodeTransitionChosen(state, routeStep, nextNodeId);
+        narrator?.OnNodeTransitionChosen(state, routeStep, state.IntentToken, allowedNextNodes, nextNodeId);
 
         var nextIndex = FindRouteStepIndex(plan.Steps, nextNodeId);
         if (nextIndex < 0 || plan.Steps[nextIndex] is not RouteStep nextStep)
@@ -442,22 +512,33 @@ public static class RouteGate
                 "Next route step is invalid.",
                 nextNodeId);
             nextState = state with { Status = RoutingStatus.Halted };
-            narrator?.OnNodeHalted(state, routeStep, error);
+            narrator?.OnNodeHalted(state, routeStep, state.IntentToken, allowedNextNodes, error);
             narrator?.OnHalted(nextState, error);
             return false;
         }
 
+        var nextToken = RouteIntentTokenFactory.Create(plan.Request.WorkOrder!, nextStep);
+
         nextState = state with
         {
+            IntentToken = nextToken,
             CurrentRouteIndex = nextIndex,
             CurrentRouteIntent = nextStep.Intent,
             Status = RoutingStatus.Pending
         };
-        narrator?.OnNodeAdvanced(nextState, routeStep, nextNodeId);
+        narrator?.OnNodeAdvanced(nextState, routeStep, state.IntentToken, allowedNextNodes, nextNodeId);
         error = null;
         return true;
     }
 
+    private static bool IsIntentCompatible(RouteIntent intent, MermaidNodeKind nodeKind)
+    {
+        if (nodeKind == MermaidNodeKind.Terminate)
+            return intent == RouteIntent.Terminate;
+
+        return intent != RouteIntent.Terminate;
+    }
+
     private static int FindRouteStepIndex(
         IReadOnlyList<BuildStep> steps,
         string nodeId)
diff --git a/src/Runtime/Shoots.Runtime.Abstractions/RouteIntentTokenFactory.cs b/src/Runtime/Shoots.Runtime.Abstractions/RouteIntentTokenFactory.cs
new file mode 100644
index 0000000..bf212da
--- /dev/null
+++ b/src/Runtime/Shoots.Runtime.Abstractions/RouteIntentTokenFactory.cs
@@ -0,0 +1,56 @@
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Security.Cryptography;
+using System.Text;
+using Shoots.Contracts.Core;
+
+namespace Shoots.Runtime.Abstractions;
+
+public static class RouteIntentTokenFactory
+{
+    public static RouteIntentToken Create(WorkOrder workOrder, RouteStep originStep)
+    {
+        if (workOrder is null)
+            throw new ArgumentNullException(nameof(workOrder));
+        if (originStep is null)
+            throw new ArgumentNullException(nameof(originStep));
+
+        var constraintsHash = ComputeConstraintsHash(workOrder.Constraints ?? Array.Empty<string>());
+        return new RouteIntentToken(
+            workOrder.Id,
+            originStep.Intent,
+            originStep.NodeId,
+            constraintsHash);
+    }
+
+    public static string ComputeTokenHash(RouteIntentToken token)
+    {
+        if (token is null)
+            throw new ArgumentNullException(nameof(token));
+
+        var builder = new StringBuilder();
+        builder.Append("workorder=").Append(token.WorkOrderId.Value.Trim());
+        builder.Append("|intent=").Append(token.Intent.ToString());
+        builder.Append("|origin=").Append(token.OriginNodeId.Trim());
+        builder.Append("|constraints=").Append(token.ConstraintsHash.Trim());
+
+        return ComputeHash(builder.ToString());
+    }
+
+    private static string ComputeConstraintsHash(IEnumerable<string> constraints)
+    {
+        var normalized = constraints
+            .Select(item => item?.Trim() ?? string.Empty)
+            .OrderBy(item => item, StringComparer.Ordinal)
+            .ToArray();
+
+        return ComputeHash(string.Join("|", normalized));
+    }
+
+    private static string ComputeHash(string value)
+    {
+        var bytes = Encoding.UTF8.GetBytes(value);
+        return Convert.ToHexString(SHA256.HashData(bytes)).ToLowerInvariant();
+    }
+}
diff --git a/src/Runtime/Shoots.Runtime.Abstractions/RoutingState.cs b/src/Runtime/Shoots.Runtime.Abstractions/RoutingState.cs
index 4937f0d..814a2fa 100644
--- a/src/Runtime/Shoots.Runtime.Abstractions/RoutingState.cs
+++ b/src/Runtime/Shoots.Runtime.Abstractions/RoutingState.cs
@@ -16,6 +16,7 @@ public enum RoutingStatus
 /// </summary>
 public sealed record RoutingState(
     WorkOrderId WorkOrderId,
+    RouteIntentToken IntentToken,
     int CurrentRouteIndex,
     RouteIntent CurrentRouteIntent,
     RoutingStatus Status
@@ -34,8 +35,11 @@ public sealed record RoutingState(
         if (firstStep.Intent == RouteIntent.Terminate)
             throw new ArgumentException("first route step cannot be terminate", nameof(plan));
 
+        var token = RouteIntentTokenFactory.Create(plan.Request.WorkOrder, firstStep);
+
         return new RoutingState(
             plan.Request.WorkOrder.Id,
+            token,
             0,
             firstStep.Intent,
             RoutingStatus.Pending);
@@ -54,8 +58,11 @@ public sealed record RoutingState(
         if (firstStep.Intent == RouteIntent.Terminate)
             throw new ArgumentException("first route step cannot be terminate", nameof(plan));
 
+        var token = RouteIntentTokenFactory.Create(workOrder, firstStep);
+
         return new RoutingState(
             workOrder.Id,
+            token,
             0,
             firstStep.Intent,
             RoutingStatus.Pending);
diff --git a/src/Runtime/Shoots.Runtime.Core/NullRuntimeNarrator.cs b/src/Runtime/Shoots.Runtime.Core/NullRuntimeNarrator.cs
index bbcad74..1d1c590 100644
--- a/src/Runtime/Shoots.Runtime.Core/NullRuntimeNarrator.cs
+++ b/src/Runtime/Shoots.Runtime.Core/NullRuntimeNarrator.cs
@@ -1,3 +1,4 @@
+using System.Collections.Generic;
 using Shoots.Contracts.Core;
 using Shoots.Runtime.Abstractions;
 
@@ -42,48 +43,62 @@ public sealed class NullRuntimeNarrator : IRuntimeNarrator
         if (workOrder is null) throw new ArgumentNullException(nameof(workOrder));
     }
 
-    public void OnRouteEntered(RoutingState state, RouteStep step)
+    public void OnRouteEntered(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes)
     {
         if (state is null) throw new ArgumentNullException(nameof(state));
         if (step is null) throw new ArgumentNullException(nameof(step));
+        if (intentToken is null) throw new ArgumentNullException(nameof(intentToken));
+        if (allowedNextNodes is null) throw new ArgumentNullException(nameof(allowedNextNodes));
     }
 
-    public void OnNodeEntered(RoutingState state, RouteStep step)
+    public void OnNodeEntered(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes)
     {
         if (state is null) throw new ArgumentNullException(nameof(state));
         if (step is null) throw new ArgumentNullException(nameof(step));
+        if (intentToken is null) throw new ArgumentNullException(nameof(intentToken));
+        if (allowedNextNodes is null) throw new ArgumentNullException(nameof(allowedNextNodes));
     }
 
-    public void OnDecisionRequired(RoutingState state, RouteStep step)
+    public void OnDecisionRequired(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes)
     {
         if (state is null) throw new ArgumentNullException(nameof(state));
         if (step is null) throw new ArgumentNullException(nameof(step));
+        if (intentToken is null) throw new ArgumentNullException(nameof(intentToken));
+        if (allowedNextNodes is null) throw new ArgumentNullException(nameof(allowedNextNodes));
     }
 
-    public void OnDecisionAccepted(RoutingState state, RouteStep step)
+    public void OnDecisionAccepted(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes)
     {
         if (state is null) throw new ArgumentNullException(nameof(state));
         if (step is null) throw new ArgumentNullException(nameof(step));
+        if (intentToken is null) throw new ArgumentNullException(nameof(intentToken));
+        if (allowedNextNodes is null) throw new ArgumentNullException(nameof(allowedNextNodes));
     }
 
-    public void OnNodeTransitionChosen(RoutingState state, RouteStep step, string nextNodeId)
+    public void OnNodeTransitionChosen(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes, string nextNodeId)
     {
         if (state is null) throw new ArgumentNullException(nameof(state));
         if (step is null) throw new ArgumentNullException(nameof(step));
+        if (intentToken is null) throw new ArgumentNullException(nameof(intentToken));
+        if (allowedNextNodes is null) throw new ArgumentNullException(nameof(allowedNextNodes));
         if (nextNodeId is null) throw new ArgumentNullException(nameof(nextNodeId));
     }
 
-    public void OnNodeAdvanced(RoutingState state, RouteStep step, string nextNodeId)
+    public void OnNodeAdvanced(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes, string nextNodeId)
     {
         if (state is null) throw new ArgumentNullException(nameof(state));
         if (step is null) throw new ArgumentNullException(nameof(step));
+        if (intentToken is null) throw new ArgumentNullException(nameof(intentToken));
+        if (allowedNextNodes is null) throw new ArgumentNullException(nameof(allowedNextNodes));
         if (nextNodeId is null) throw new ArgumentNullException(nameof(nextNodeId));
     }
 
-    public void OnNodeHalted(RoutingState state, RouteStep step, RuntimeError error)
+    public void OnNodeHalted(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes, RuntimeError error)
     {
         if (state is null) throw new ArgumentNullException(nameof(state));
         if (step is null) throw new ArgumentNullException(nameof(step));
+        if (intentToken is null) throw new ArgumentNullException(nameof(intentToken));
+        if (allowedNextNodes is null) throw new ArgumentNullException(nameof(allowedNextNodes));
         if (error is null) throw new ArgumentNullException(nameof(error));
     }
 
@@ -93,9 +108,11 @@ public sealed class NullRuntimeNarrator : IRuntimeNarrator
         if (error is null) throw new ArgumentNullException(nameof(error));
     }
 
-    public void OnCompleted(RoutingState state, RouteStep step)
+    public void OnCompleted(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes)
     {
         if (state is null) throw new ArgumentNullException(nameof(state));
         if (step is null) throw new ArgumentNullException(nameof(step));
+        if (intentToken is null) throw new ArgumentNullException(nameof(intentToken));
+        if (allowedNextNodes is null) throw new ArgumentNullException(nameof(allowedNextNodes));
     }
 }
diff --git a/src/Runtime/Shoots.Runtime.Core/RoutingLoop.cs b/src/Runtime/Shoots.Runtime.Core/RoutingLoop.cs
index d404dd2..9282c8d 100644
--- a/src/Runtime/Shoots.Runtime.Core/RoutingLoop.cs
+++ b/src/Runtime/Shoots.Runtime.Core/RoutingLoop.cs
@@ -150,7 +150,7 @@ public sealed class RoutingLoop
             .FirstOrDefault(candidate => string.Equals(candidate.NodeId, step.NodeId, StringComparison.Ordinal));
         var nodeKind = rule?.NodeKind ?? MermaidNodeKind.Linear;
         var allowedNextNodes = rule?.AllowedNextNodes ?? Array.Empty<string>();
-        var request = new AiDecisionRequest(_plan.Request.WorkOrder!, step, State, _catalogHash, summary, nodeKind, allowedNextNodes);
+        var request = new AiDecisionRequest(_plan.Request.WorkOrder!, step, State, _catalogHash, summary, nodeKind, allowedNextNodes, State.IntentToken);
         return _aiDecisionProvider.RequestDecision(request);
     }
 
diff --git a/src/Runtime/Shoots.Runtime.Core/RuntimeOrchestrator.cs b/src/Runtime/Shoots.Runtime.Core/RuntimeOrchestrator.cs
index 7b26b59..abb9495 100644
--- a/src/Runtime/Shoots.Runtime.Core/RuntimeOrchestrator.cs
+++ b/src/Runtime/Shoots.Runtime.Core/RuntimeOrchestrator.cs
@@ -116,6 +116,60 @@ public sealed class RuntimeOrchestrator
 
         var resumeState = ResolveLastNonTerminalState(trace) ?? lastState ?? RoutingState.CreateInitial(trace.Plan);
 
+        if (resumeState.IntentToken is null)
+            return HaltFromTrace(trace, registry, toolResults, resumeState, "route_intent_token_missing", "Intent token is required.");
+
+        if (trace.Plan.Request.WorkOrder is null)
+            return HaltFromTrace(trace, registry, toolResults, resumeState, "route_workorder_missing", "Work order is required for routing.");
+
+        if (!string.Equals(resumeState.IntentToken.WorkOrderId.Value, trace.Plan.Request.WorkOrder.Id.Value, StringComparison.Ordinal))
+        {
+            return HaltFromTrace(
+                trace,
+                registry,
+                toolResults,
+                resumeState,
+                "route_intent_token_workorder_mismatch",
+                "Intent token work order does not match plan work order.");
+        }
+
+        var resumeStep = ResolveRouteStep(trace.Plan, resumeState.CurrentRouteIndex);
+        var expectedToken = RouteIntentTokenFactory.Create(trace.Plan.Request.WorkOrder, resumeStep);
+        var expectedHash = RouteIntentTokenFactory.ComputeTokenHash(expectedToken);
+        var actualHash = RouteIntentTokenFactory.ComputeTokenHash(resumeState.IntentToken);
+        if (!string.Equals(expectedHash, actualHash, StringComparison.Ordinal))
+        {
+            return HaltFromTrace(
+                trace,
+                registry,
+                toolResults,
+                resumeState,
+                "route_intent_token_mismatch",
+                "Intent token hash mismatch.");
+        }
+
+        if (trace.Plan.Request.RouteRules is null)
+        {
+            return HaltFromTrace(
+                trace,
+                registry,
+                toolResults,
+                resumeState,
+                "route_rules_missing",
+                "Route rules are required to resume routing.");
+        }
+
+        if (!trace.Plan.Request.RouteRules.Any(rule => string.Equals(rule.NodeId, resumeStep.NodeId, StringComparison.Ordinal)))
+        {
+            return HaltFromTrace(
+                trace,
+                registry,
+                toolResults,
+                resumeState,
+                "route_node_missing",
+                $"Route node '{resumeStep.NodeId}' is not present in the Mermaid graph.");
+        }
+
         var loop = new RoutingLoop(
             trace.Plan,
             registry,
@@ -141,6 +195,18 @@ public sealed class RuntimeOrchestrator
             finalStatus);
     }
 
+    private static RouteStep ResolveRouteStep(BuildPlan plan, int index)
+    {
+        if (plan.Steps is null || plan.Steps.Count == 0)
+            throw new ArgumentException("route steps are required", nameof(plan));
+        if (index < 0 || index >= plan.Steps.Count)
+            throw new ArgumentOutOfRangeException(nameof(index), "route step index is out of range");
+        if (plan.Steps[index] is not RouteStep routeStep)
+            throw new ArgumentException("route step is required", nameof(plan));
+
+        return routeStep;
+    }
+
     private static ExecutionFinalStatus ResolveFinalStatus(RoutingState state)
     {
         return state.Status switch
diff --git a/src/Runtime/Shoots.Runtime.Core/TracingRuntimeNarrator.cs b/src/Runtime/Shoots.Runtime.Core/TracingRuntimeNarrator.cs
index a5cd9ce..1a0f49c 100644
--- a/src/Runtime/Shoots.Runtime.Core/TracingRuntimeNarrator.cs
+++ b/src/Runtime/Shoots.Runtime.Core/TracingRuntimeNarrator.cs
@@ -1,4 +1,5 @@
 using System;
+using System.Collections.Generic;
 using Shoots.Contracts.Core;
 using Shoots.Runtime.Abstractions;
 
@@ -52,46 +53,53 @@ internal sealed class TracingRuntimeNarrator : IRuntimeNarrator
         _inner.OnWorkOrderReceived(workOrder);
     }
 
-    public void OnRouteEntered(RoutingState state, RouteStep step)
+    public void OnRouteEntered(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes)
     {
-        _trace.Add(RoutingTraceEventKind.RouteEntered, step.NodeId, state, step);
-        _inner.OnRouteEntered(state, step);
+        var detail = BuildRouteDetail(step.NodeId, intentToken, allowedNextNodes, null);
+        _trace.Add(RoutingTraceEventKind.RouteEntered, detail, state, step);
+        _inner.OnRouteEntered(state, step, intentToken, allowedNextNodes);
     }
 
-    public void OnNodeEntered(RoutingState state, RouteStep step)
+    public void OnNodeEntered(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes)
     {
-        _trace.Add(RoutingTraceEventKind.NodeEntered, step.NodeId, state, step);
-        _inner.OnNodeEntered(state, step);
+        var detail = BuildRouteDetail(step.NodeId, intentToken, allowedNextNodes, null);
+        _trace.Add(RoutingTraceEventKind.NodeEntered, detail, state, step);
+        _inner.OnNodeEntered(state, step, intentToken, allowedNextNodes);
     }
 
-    public void OnDecisionRequired(RoutingState state, RouteStep step)
+    public void OnDecisionRequired(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes)
     {
-        _trace.Add(RoutingTraceEventKind.DecisionRequired, step.NodeId, state, step);
-        _inner.OnDecisionRequired(state, step);
+        var detail = BuildRouteDetail(step.NodeId, intentToken, allowedNextNodes, null);
+        _trace.Add(RoutingTraceEventKind.DecisionRequired, detail, state, step);
+        _inner.OnDecisionRequired(state, step, intentToken, allowedNextNodes);
     }
 
-    public void OnDecisionAccepted(RoutingState state, RouteStep step)
+    public void OnDecisionAccepted(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes)
     {
-        _trace.Add(RoutingTraceEventKind.DecisionAccepted, step.NodeId, state, step);
-        _inner.OnDecisionAccepted(state, step);
+        var detail = BuildRouteDetail(step.NodeId, intentToken, allowedNextNodes, null);
+        _trace.Add(RoutingTraceEventKind.DecisionAccepted, detail, state, step);
+        _inner.OnDecisionAccepted(state, step, intentToken, allowedNextNodes);
     }
 
-    public void OnNodeTransitionChosen(RoutingState state, RouteStep step, string nextNodeId)
+    public void OnNodeTransitionChosen(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes, string nextNodeId)
     {
-        _trace.Add(RoutingTraceEventKind.NodeTransitionChosen, $"{step.NodeId}->{nextNodeId}", state, step);
-        _inner.OnNodeTransitionChosen(state, step, nextNodeId);
+        var detail = BuildRouteDetail(step.NodeId, intentToken, allowedNextNodes, nextNodeId);
+        _trace.Add(RoutingTraceEventKind.NodeTransitionChosen, detail, state, step);
+        _inner.OnNodeTransitionChosen(state, step, intentToken, allowedNextNodes, nextNodeId);
     }
 
-    public void OnNodeAdvanced(RoutingState state, RouteStep step, string nextNodeId)
+    public void OnNodeAdvanced(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes, string nextNodeId)
     {
-        _trace.Add(RoutingTraceEventKind.NodeAdvanced, $"{step.NodeId}->{nextNodeId}", state, step);
-        _inner.OnNodeAdvanced(state, step, nextNodeId);
+        var detail = BuildRouteDetail(step.NodeId, intentToken, allowedNextNodes, nextNodeId);
+        _trace.Add(RoutingTraceEventKind.NodeAdvanced, detail, state, step);
+        _inner.OnNodeAdvanced(state, step, intentToken, allowedNextNodes, nextNodeId);
     }
 
-    public void OnNodeHalted(RoutingState state, RouteStep step, RuntimeError error)
+    public void OnNodeHalted(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes, RuntimeError error)
     {
-        _trace.Add(RoutingTraceEventKind.NodeHalted, error.Code, state, step, error);
-        _inner.OnNodeHalted(state, step, error);
+        var detail = BuildRouteDetail(step.NodeId, intentToken, allowedNextNodes, null);
+        _trace.Add(RoutingTraceEventKind.NodeHalted, detail, state, step, error);
+        _inner.OnNodeHalted(state, step, intentToken, allowedNextNodes, error);
     }
 
     public void OnHalted(RoutingState state, RuntimeError error)
@@ -100,9 +108,24 @@ internal sealed class TracingRuntimeNarrator : IRuntimeNarrator
         _inner.OnHalted(state, error);
     }
 
-    public void OnCompleted(RoutingState state, RouteStep step)
+    public void OnCompleted(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes)
     {
-        _trace.Add(RoutingTraceEventKind.Completed, step.NodeId, state, step);
-        _inner.OnCompleted(state, step);
+        var detail = BuildRouteDetail(step.NodeId, intentToken, allowedNextNodes, null);
+        _trace.Add(RoutingTraceEventKind.Completed, detail, state, step);
+        _inner.OnCompleted(state, step, intentToken, allowedNextNodes);
+    }
+
+    private static string BuildRouteDetail(
+        string nodeId,
+        RouteIntentToken intentToken,
+        IReadOnlyList<string> allowedNextNodes,
+        string? selectedNextNodeId)
+    {
+        var nextNodes = allowedNextNodes.Count == 0
+            ? string.Empty
+            : string.Join(",", allowedNextNodes);
+        var tokenHash = RouteIntentTokenFactory.ComputeTokenHash(intentToken);
+        var detail = $"node={nodeId}|intent={tokenHash}|next={nextNodes}";
+        return selectedNextNodeId is null ? detail : $"{detail}|selected={selectedNextNodeId}";
     }
 }
diff --git a/src/Runtime/Shoots.Runtime.Tests/RouteGateTests.cs b/src/Runtime/Shoots.Runtime.Tests/RouteGateTests.cs
index bc12fc9..d906ba6 100644
--- a/src/Runtime/Shoots.Runtime.Tests/RouteGateTests.cs
+++ b/src/Runtime/Shoots.Runtime.Tests/RouteGateTests.cs
@@ -21,6 +21,7 @@ public sealed class RouteGateTests
 
         var state = new RoutingState(
             new WorkOrderId("wo-other"),
+            CreateIntentToken(plan),
             0,
             RouteIntent.Validate,
             RoutingStatus.Pending);
@@ -68,6 +69,7 @@ public sealed class RouteGateTests
         var state = RoutingState.CreateInitial(plan);
         var decision = new RouteDecision(
             "terminate",
+            RouteIntent.Validate,
             new ToolSelectionDecision(
                 new ToolId("tools.any"),
                 new Dictionary<string, object?>()));
@@ -110,6 +112,7 @@ public sealed class RouteGateTests
 
             var decision = new RouteDecision(
                 "validate",
+                RouteIntent.SelectTool,
                 new ToolSelectionDecision(toolSpec.ToolId, new Dictionary<string, object?>()));
             var advanced = RouteGate.TryAdvance(plan, state, decision, registry, out var nextState, out var error);
 
@@ -143,6 +146,7 @@ public sealed class RouteGateTests
         var state = RoutingState.CreateInitial(plan);
         var decision = new RouteDecision(
             "terminate",
+            RouteIntent.Validate,
             new ToolSelectionDecision(new ToolId("tools.any"), new Dictionary<string, object?>()));
 
         var result = RouteGate.TryAdvance(plan, state, decision, new SnapshotOnlyRegistry(), out var nextState, out var error);
@@ -167,11 +171,13 @@ public sealed class RouteGateTests
 
         var lateState = new RoutingState(
             plan.Request.WorkOrder.Id,
+            CreateIntentToken(plan),
             1,
             RouteIntent.Validate,
             RoutingStatus.Pending);
         var decision = new RouteDecision(
             "terminate",
+            RouteIntent.SelectTool,
             new ToolSelectionDecision(new ToolId("tools.any"), new Dictionary<string, object?>()));
 
         var result = RouteGate.TryAdvance(plan, lateState, decision, new SnapshotOnlyRegistry(), out var nextState, out var error);
@@ -208,6 +214,7 @@ public sealed class RouteGateTests
         var state = RoutingState.CreateInitial(plan);
         var decision = new RouteDecision(
             "terminate",
+            RouteIntent.SelectTool,
             new ToolSelectionDecision(toolSpec.ToolId, new Dictionary<string, object?>()));
 
         var result = RouteGate.TryAdvance(plan, state, decision, registry, out var nextState, out var error);
@@ -235,6 +242,7 @@ public sealed class RouteGateTests
         {
             var state = new RoutingState(
                 new WorkOrderId("wo-other"),
+                CreateIntentToken(plan),
                 0,
                 RouteIntent.Validate,
                 RoutingStatus.Pending);
@@ -276,6 +284,7 @@ public sealed class RouteGateTests
 
         var decision = new RouteDecision(
             "terminate",
+            RouteIntent.SelectTool,
             new ToolSelectionDecision(toolSpec.ToolId, new Dictionary<string, object?>()));
         var advanced = RouteGate.TryAdvance(plan, state, decision, registry, out var nextState, out var error);
 
@@ -307,6 +316,7 @@ public sealed class RouteGateTests
         var state = RoutingState.CreateInitial(plan);
         var decision = new RouteDecision(
             "terminate",
+            RouteIntent.SelectTool,
             new ToolSelectionDecision(new ToolId("tools.any"), new Dictionary<string, object?>()));
 
         var result = RouteGate.TryAdvance(plan, state, decision, new SnapshotOnlyRegistry(), out var nextState, out var error);
@@ -330,11 +340,13 @@ public sealed class RouteGateTests
 
         var state = new RoutingState(
             new WorkOrderId("wo-other"),
+            CreateIntentToken(plan),
             0,
             RouteIntent.SelectTool,
             RoutingStatus.Pending);
         var decision = new RouteDecision(
             "terminate",
+            RouteIntent.SelectTool,
             new ToolSelectionDecision(new ToolId("tools.any"), new Dictionary<string, object?>()));
 
         var result = RouteGate.TryAdvance(plan, state, decision, new SnapshotOnlyRegistry(), out var nextState, out var error);
@@ -463,14 +475,20 @@ public sealed class RouteGateTests
         public void OnError(RuntimeError error) => Events.Add("error");
         public void OnRoute(RouteNarration narration) => Events.Add("route");
         public void OnWorkOrderReceived(WorkOrder workOrder) => Events.Add("workorder");
-        public void OnRouteEntered(RoutingState state, RouteStep step) => Events.Add("entered");
-        public void OnNodeEntered(RoutingState state, RouteStep step) => Events.Add("node.entered");
-        public void OnDecisionRequired(RoutingState state, RouteStep step) => Events.Add("decision.required");
-        public void OnDecisionAccepted(RoutingState state, RouteStep step) => Events.Add("decision.accepted");
-        public void OnNodeTransitionChosen(RoutingState state, RouteStep step, string nextNodeId) => Events.Add("node.transition");
-        public void OnNodeAdvanced(RoutingState state, RouteStep step, string nextNodeId) => Events.Add("node.advanced");
-        public void OnNodeHalted(RoutingState state, RouteStep step, RuntimeError error) => Events.Add("node.halted");
+        public void OnRouteEntered(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes) => Events.Add("entered");
+        public void OnNodeEntered(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes) => Events.Add("node.entered");
+        public void OnDecisionRequired(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes) => Events.Add("decision.required");
+        public void OnDecisionAccepted(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes) => Events.Add("decision.accepted");
+        public void OnNodeTransitionChosen(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes, string nextNodeId) => Events.Add("node.transition");
+        public void OnNodeAdvanced(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes, string nextNodeId) => Events.Add("node.advanced");
+        public void OnNodeHalted(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes, RuntimeError error) => Events.Add("node.halted");
         public void OnHalted(RoutingState state, RuntimeError error) => Events.Add("halted");
-        public void OnCompleted(RoutingState state, RouteStep step) => Events.Add("completed");
+        public void OnCompleted(RoutingState state, RouteStep step, RouteIntentToken intentToken, IReadOnlyList<string> allowedNextNodes) => Events.Add("completed");
+    }
+
+    private static RouteIntentToken CreateIntentToken(BuildPlan plan)
+    {
+        var originStep = plan.Steps[0] as RouteStep ?? throw new InvalidOperationException("first step must be a route step");
+        return RouteIntentTokenFactory.Create(plan.Request.WorkOrder, originStep);
     }
 }
diff --git a/src/Runtime/Shoots.Runtime.Tests/RoutingLoopTests.cs b/src/Runtime/Shoots.Runtime.Tests/RoutingLoopTests.cs
index 747ca6a..7c7593b 100644
--- a/src/Runtime/Shoots.Runtime.Tests/RoutingLoopTests.cs
+++ b/src/Runtime/Shoots.Runtime.Tests/RoutingLoopTests.cs
@@ -157,6 +157,7 @@ public sealed class RoutingLoopTests
 
             return new RouteDecision(
                 "terminate",
+                request.IntentToken.Intent,
                 new ToolSelectionDecision(new ToolId("tools.sample"), new Dictionary<string, object?>()));
         }
     }
