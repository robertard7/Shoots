diff --git a/src/Contracts/Shoots.Contracts.Core/ToolContracts.cs b/src/Contracts/Shoots.Contracts.Core/ToolContracts.cs
index 818ea54..4f970b4 100644
--- a/src/Contracts/Shoots.Contracts.Core/ToolContracts.cs
+++ b/src/Contracts/Shoots.Contracts.Core/ToolContracts.cs
@@ -42,11 +42,3 @@ public sealed record ToolSpec(
     IReadOnlyList<ToolInputSpec> Inputs,
     IReadOnlyList<ToolOutputSpec> Outputs
 );
-
-/// <summary>
-/// Tool contract boundary (no execution logic).
-/// </summary>
-public interface ITool
-{
-    ToolSpec Spec { get; }
-}
diff --git a/src/Runtime/Shoots.Runtime.Abstractions/ITool.cs b/src/Runtime/Shoots.Runtime.Abstractions/ITool.cs
new file mode 100644
index 0000000..8ca4c6f
--- /dev/null
+++ b/src/Runtime/Shoots.Runtime.Abstractions/ITool.cs
@@ -0,0 +1,11 @@
+using Shoots.Contracts.Core;
+
+namespace Shoots.Runtime.Abstractions;
+
+/// <summary>
+/// Tool contract boundary (no execution logic).
+/// </summary>
+public interface ITool
+{
+    ToolSpec Spec { get; }
+}
diff --git a/src/Runtime/Shoots.Runtime.Abstractions/ToolAuthorityValidator.cs b/src/Runtime/Shoots.Runtime.Abstractions/ToolAuthorityValidator.cs
new file mode 100644
index 0000000..03e1e1a
--- /dev/null
+++ b/src/Runtime/Shoots.Runtime.Abstractions/ToolAuthorityValidator.cs
@@ -0,0 +1,61 @@
+using System;
+using Shoots.Contracts.Core;
+
+namespace Shoots.Runtime.Abstractions;
+
+public static class ToolAuthorityValidator
+{
+    public static bool TryValidate(
+        BuildPlan plan,
+        IToolRegistry registry,
+        DelegationAuthority authority,
+        out RuntimeError? error)
+    {
+        if (plan is null)
+            throw new ArgumentNullException(nameof(plan));
+        if (registry is null)
+            throw new ArgumentNullException(nameof(registry));
+
+        foreach (var step in plan.Steps)
+        {
+            if (step is not ToolBuildStep toolStep)
+                continue;
+
+            var entry = registry.GetTool(toolStep.ToolId);
+            if (entry is null)
+            {
+                error = new RuntimeError(
+                    "tool_missing",
+                    $"Tool '{toolStep.ToolId.Value}' is not registered.");
+                return false;
+            }
+
+            if (!MeetsAuthority(authority, entry.Spec.RequiredAuthority))
+            {
+                error = new RuntimeError(
+                    "tool_authority_denied",
+                    $"Tool '{toolStep.ToolId.Value}' requires '{entry.Spec.RequiredAuthority.RequiredProviderKind}' authority.");
+                return false;
+            }
+        }
+
+        error = null;
+        return true;
+    }
+
+    private static bool MeetsAuthority(
+        DelegationAuthority authority,
+        ToolAuthorityScope required)
+    {
+        if (authority.Kind < required.RequiredProviderKind)
+            return false;
+
+        var capabilities = GetCapabilities(authority.Kind);
+        return (capabilities & required.RequiredCapabilities) == required.RequiredCapabilities;
+    }
+
+    private static ProviderCapabilities GetCapabilities(ProviderKind kind)
+    {
+        return ProviderCapabilities.Plan | ProviderCapabilities.Execute | ProviderCapabilities.Artifacts;
+    }
+}
diff --git a/src/Runtime/Shoots.Runtime.Tests/ToolAuthorityValidatorTests.cs b/src/Runtime/Shoots.Runtime.Tests/ToolAuthorityValidatorTests.cs
new file mode 100644
index 0000000..b9a7a65
--- /dev/null
+++ b/src/Runtime/Shoots.Runtime.Tests/ToolAuthorityValidatorTests.cs
@@ -0,0 +1,106 @@
+using System.Collections.Generic;
+using System.Linq;
+using Shoots.Contracts.Core;
+using Shoots.Runtime.Abstractions;
+using Xunit;
+
+namespace Shoots.Runtime.Tests;
+
+public sealed class ToolAuthorityValidatorTests
+{
+    [Fact]
+    public void Validation_denies_when_tool_requires_higher_authority()
+    {
+        var planAuthority = new DelegationAuthority(
+            ProviderId: new ProviderId("local"),
+            Kind: ProviderKind.Local,
+            PolicyId: "local-only",
+            AllowsDelegation: false
+        );
+
+        var toolSpec = new ToolSpec(
+            new ToolId("tools.remote"),
+            "Remote tool.",
+            new ToolAuthorityScope(ProviderKind.Remote, ProviderCapabilities.None),
+            new List<ToolInputSpec>(),
+            new List<ToolOutputSpec>());
+
+        var plan = CreatePlan(planAuthority, toolSpec.ToolId);
+        var registry = new StubToolRegistry(toolSpec);
+
+        var result = ToolAuthorityValidator.TryValidate(plan, registry, planAuthority, out var error);
+
+        Assert.False(result);
+        Assert.NotNull(error);
+        Assert.Equal("tool_authority_denied", error!.Code);
+    }
+
+    [Fact]
+    public void Validation_allows_when_authority_meets_requirement()
+    {
+        var planAuthority = new DelegationAuthority(
+            ProviderId: new ProviderId("local"),
+            Kind: ProviderKind.Local,
+            PolicyId: "local-only",
+            AllowsDelegation: false
+        );
+
+        var toolSpec = new ToolSpec(
+            new ToolId("tools.local"),
+            "Local tool.",
+            new ToolAuthorityScope(ProviderKind.Local, ProviderCapabilities.None),
+            new List<ToolInputSpec>(),
+            new List<ToolOutputSpec>());
+
+        var plan = CreatePlan(planAuthority, toolSpec.ToolId);
+        var registry = new StubToolRegistry(toolSpec);
+
+        var result = ToolAuthorityValidator.TryValidate(plan, registry, planAuthority, out var error);
+
+        Assert.True(result);
+        Assert.Null(error);
+    }
+
+    private static BuildPlan CreatePlan(DelegationAuthority authority, ToolId toolId)
+    {
+        var request = new BuildRequest("core.tool", new Dictionary<string, object?>());
+        var steps = new BuildStep[]
+        {
+            new ToolBuildStep(
+                "tool-step",
+                "Use tool.",
+                toolId,
+                new Dictionary<string, object?>(),
+                new[] { new ToolOutputSpec("result", "string", "Result.") })
+        };
+        var artifacts = new[] { new BuildArtifact("plan.json", "Plan payload.") };
+
+        return new BuildPlan(
+            PlanId: "plan",
+            Request: request,
+            Authority: authority,
+            Steps: steps,
+            Artifacts: artifacts);
+    }
+
+    private sealed class StubToolRegistry : IToolRegistry
+    {
+        private readonly IReadOnlyDictionary<ToolId, ToolRegistryEntry> _entries;
+
+        public StubToolRegistry(params ToolSpec[] specs)
+        {
+            var entries = new Dictionary<ToolId, ToolRegistryEntry>();
+            foreach (var spec in specs)
+                entries[spec.ToolId] = new ToolRegistryEntry(spec);
+
+            _entries = entries;
+        }
+
+        public IReadOnlyList<ToolRegistryEntry> GetAllTools() => _entries.Values.ToList();
+
+        public ToolRegistryEntry? GetTool(ToolId toolId)
+        {
+            return _entries.TryGetValue(toolId, out var entry) ? entry : null;
+        }
+    }
+}
